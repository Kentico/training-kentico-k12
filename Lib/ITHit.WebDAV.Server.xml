<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ITHit.WebDAV.Server</name>
    </assembly>
    <members>
        <member name="T:ITHit.WebDAV.Server.Handler.BaseUploadHandler.IUploadItemInfo">
            <summary>
            Information about resource being uploaded.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Handler.BaseUploadHandler.IUploadItemInfo.GetParentAndName(System.String@)">
            <summary>
            Returns parent folder and name of the resource.
            </summary>            
        </member>
        <member name="M:ITHit.WebDAV.Server.Handler.BaseUploadHandler.IUploadItemInfo.GetItem">
            <summary>
            Returns resource being uploaded.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Handler.BaseUploadHandler.IUploadItemInfo.Stream">
            <summary>
            Returns upload stream.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Handler.BaseUploadHandler.IUploadItemInfo.ContentType">
            <summary>
            Resource's content type.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.CancelUploadDAVHandler">
            <summary>
            Summary description for CancelUploadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.BaseDAVHandler">
            <summary>
            Summary description for BaseDAVHandler.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Handler.BaseDAVHandler.GetParentAndAllowedName(System.String,System.String@,System.String@)">
            <summary>
            Gets parent name from path, original name from path and original name transformed to allowed name.
            </summary>
            <param name="path">Path for splitting</param>
            <param name="name">Original name from path</param>
            <param name="allowedName">Original name transformed to allowed name</param>
            <returns>IFolder containing parent</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Handler.BaseDAVHandler.GetItemByPathWithName(ITHit.WebDAV.Server.Engine,ITHit.WebDAV.Server.Request,System.String,System.String,System.String@)">
            <summary>
            Gets item by path and transforms given name of hierarchy item to allowed format.
            </summary>
            <param name="engine">WebDAV engine to be used</param>
            <param name="request">WebDAV request</param>
            <param name="path">Path for which to lookup the hierarchy item</param>
            <param name="name">Name of new hierachy item</param>
            <param name="outName">Name of new hierarchy item in allwoed format</param>
            <returns>Hierarchy item for path</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Handler.CheckinDAVHandler.#ctor(ITHit.WebDAV.Server.Engine)">
            <summary>
            Summary description for CheckinDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.CopyDAVHandler">
            <summary>
            Summary description for CopyDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.DeleteDAVHandler">
            <summary>
            Summary description for DeleteDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.GetDAVHandler">
            <summary>
            Summary description for GetDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.HeadDAVHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.LockDAVHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.MkcolDAVHandler">
            <summary>
            Summary description for MkcolDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.MoveDAVHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.PostDAVHandler">
            <summary>
            Summary description for PostDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.PropfindDAVHandler">
            <summary>
            Summary description for PropfindDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.ProppatchDAVHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Handler.ReportDAVHandler.GenerateReportResponse(ITHit.WebDAV.Server.DeltaV.IHistory)">
            <param name="history">Version history of the requested version or resource</param>
        </member>
        <member name="T:ITHit.WebDAV.Server.Handler.UnlockDAVHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.ForbiddenResponse">
            <summary>
            Indicates that server understood the request, but is refusing to fulfill it.
            Authorization will not help and the request SHOULD NOT be repeated.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.ForbiddenResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.NotImplementedResponse">
            <summary>
            The server does not support the functionality required to fulfill the request.
            </summary>
            <remarks>
            This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.NotImplementedResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.ResumeIncompleteResponse">
            <summary>
            Indicates that content was uploaded partially.
            </summary>
            <remarks>This response indicates that it is expected that more segments will be uploaded.</remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.ResumeIncompleteResponse.#ctor">
            <summary>
            Instantiates new instance of ResumeIncompleteResponse.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.AccessDeniedResponse">
            <summary>
            Not enough permissions.
            </summary>
            <remarks>
            Indicates that operation has failed because client does not have enough permissions to perform this operation.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.AccessDeniedResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.ConflictResponse">
            <summary>
            Indicates that operation has failed due to a conflict with
            the current state of the hierarchy item.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.ConflictResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.CreatedResponse">
            <summary>
            Indicates that operation has succeeded and resulted in a new hierarchy item being created.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.CreatedResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.FailedDependencyResponse">
            <summary>
            Means that operation could not be performed on the hierarchy item because
            the requested action depended on another action and that action failed.
            </summary>
            <remarks>
            Usually you will inlude this response in the <see cref="T:ITHit.WebDAV.Server.Response.MultipropResponse"/>
            object returned from the <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(ITHit.WebDAV.Server.Property[],ITHit.WebDAV.Server.Property[])"/> method.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.FailedDependencyResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.ItemResponse">
            <summary>
            Represents response for one hierarchy item in multistatus response.
            </summary>
            <remarks>
            Usually you will use this class when you need to return multiple WebDAV responses
            from your method using <see cref="T:ITHit.WebDAV.Server.Response.MultistatusResponse"/> object.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.ItemResponse.#ctor(System.String,ITHit.WebDAV.Server.Response.WebDAVResponse)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.Response.ItemResponse"/> class.
            </summary>
            <param name="itemPath">Path of the item in the hierarchy tree</param>
            <param name="response">WebDAV response for the item</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.ItemResponse.ItemPath">
            <summary>
            Gets the path of the item.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.ItemResponse.Response">
            <summary>
            Gets the response for the item.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.LockedResponse">
            <summary>
            Indicates that operation has failed because the source or destination hierarchy item is locked
            and client did not provide lock token.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.LockedResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.MultipropResponse">
            <summary>
            Serves as responses container for multiple WebDAV properties.
            </summary>
            <remarks>
            This class serves as multistatus response for properties.
            You must return <c>MultipropResponse</c> object from your implementation of
            the <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(ITHit.WebDAV.Server.Property[],ITHit.WebDAV.Server.Property[])"/> method. You must include response for each
            property passed to the <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(ITHit.WebDAV.Server.Property[],ITHit.WebDAV.Server.Property[])"/> method in parameters.
            You can collect multiple responses using the <see cref="M:ITHit.WebDAV.Server.Response.MultipropResponse.AddResponses(ITHit.WebDAV.Server.Response.PropResponse[])"/> method.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.MultipropResponse.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.Response.MultipropResponse"/> class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.MultipropResponse.AddResponses(ITHit.WebDAV.Server.Response.PropResponse[])">
            <summary>
            Adds new responses to the private collection in this class.
            </summary>
            <param name="r">Array of responses to add to the collection</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.MultipropResponse.Responses">
            <summary>
            Gets the array of the responses for multiple properties in this multistatus response.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.MultipropResponse.ResponseDescription">
            <summary>
            Gets/sets 'responsedescription' property for multi-status response
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.MultistatusResponse">
            <summary>
            Serves as the container for multiple WebDAV responses.
            </summary>
            <remarks>
            You must return <c>MultistatusResponse</c> object if errors occur
            when you perform WebDAV operation on the hierarchy subtree.
            You can collect multiple responses using the <see cref="M:ITHit.WebDAV.Server.Response.MultistatusResponse.AddResponses(ITHit.WebDAV.Server.Response.ItemResponse[])"/> method.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.MultistatusResponse.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.Response.MultistatusResponse"/> class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.MultistatusResponse.AddResponses(ITHit.WebDAV.Server.Response.ItemResponse[])">
            <summary>
            Adds new responses to the private collection in this class.
            </summary>
            <param name="r">Array of responses to add to the collection</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.MultistatusResponse.Responses">
            <summary>
            Gets the array of the responses for multiple hierarchy items in this multistatus response.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.NoContentResponse">
            <summary>
            Indicates that operation has succeeded.
            </summary>
            <remarks>
            Has a different meaning depending on the operation invoked.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.NoContentResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.NotAllowedResponse">
            <summary>
            The invoked operation is not allowed for the hierarchy item.
            </summary>
            <remarks>
            Usually you will return this response when operation invoked for the lock-null item is not allowed.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.NotAllowedResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.OkResponse">
            <summary>
            Indicates that operation has succeeded.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.OkResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.PreconditionFailedResponse">
            <summary>
            The precondition given by the WebDAV client evaluated to false
            when it was tested on the server.
            </summary>
            <remarks>
            Usually you will return this response from the <see cref="M:ITHit.WebDAV.Server.ILock.RefreshLock(ITHit.WebDAV.Server.LockInfo@)"/>
            and <see cref="M:ITHit.WebDAV.Server.ILock.Unlock(System.String)"/> methods when the lock token included in the parameters
            was not enforceable on the hierarchy item.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.PreconditionFailedResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.PropResponse">
            <summary>
            Represents response for one property in multistatus response.
            </summary>
            <remarks>
            Usually you will use this class when you need to return multiple WebDAV responses
            from your <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(ITHit.WebDAV.Server.Property[],ITHit.WebDAV.Server.Property[])"/> method using <see cref="T:ITHit.WebDAV.Server.Response.MultipropResponse"/> object.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.PropResponse.#ctor(ITHit.WebDAV.Server.Property,ITHit.WebDAV.Server.Response.WebDAVResponse)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.Response.PropResponse"/> class.
            </summary>
            <param name="prop">Provides name and namespace of the property</param>
            <param name="response">WebDAV response for the property</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.PropResponse.PropName">
            <summary>
            Gets the property name.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.PropResponse.PropNamespace">
            <summary>
            Gets the property namespace.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.PropResponse.Response">
            <summary>
            Gets the response for the property.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.ServerErrorResponse">
            <summary>
            Server error occurred.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.ServerErrorResponse.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Response.WebDAVResponse">
            <summary>
            Serves as the base class for HTTP responses send by the WebDAV server.
            </summary>
            <remarks>
            The <c>WebDAVResponse</c> class provides the means of informing WebDAV client about the result of the operation.
            Most WebDAV Server functions return this class.
            Usually you will return one of the classes derived from <c>WebDAVResponse</c>.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Response.WebDAVResponse.m_code">
            <summary>
            Stores the status code of the HTTP response.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Response.WebDAVResponse.m_description">
            <summary>
            Stores the description of the HTTP response.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Response.WebDAVResponse.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.Response.WebDAVResponse"/> class.
            </summary>
            <param name="code">Status code of the HTTP response</param>
            <param name="description">Description of the HTTP response</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.WebDAVResponse.Code">
            <summary>
            Gets the status code of the HTTP response.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.WebDAVResponse.Description">
            <summary>
            Gets the description of the HTTP response.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Response.WebDAVResponse.IsSuccess">
            <summary>
            Indicates whether this response means success of the operation.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress">
             <summary>
             Implemented on files and folders to report upload progress.
             </summary>
             <remarks>    
             <para>This interface should be implemented on resources that can provide upload progress information to client application. Optionally it can be implemented on folder items.</para>
             <para>When implementing this interface always configure <see cref="T:ITHit.WebDAV.Server.ResumableUpload.ResumableUploadModule"/> module in your web.config file if your WebDAV server is hosted in IIS/ASP.NET.</para>
             <para>
             Usually client application requests upload progress in following cases: 
             <list type="bullet">
             <item><description>If connection was broken (paused) and client would like to restore upload. Client will submit upload-progress request to get number of bytes successfully saved on server side and will start the upload from the next byte. Usually upload restoration could be achieved only by rich client applications (.NET, Java, etc).</description></item>
             <item><description>When thin client (AJAX or other) requires information about how much of the uploaded file was processed on server side. Unlike rich client, thin client application does not have any information about how much of the file was submitted to server. Thin client will submit upload-progress request to update its upload progress bar from time to time.</description></item>
             </list>
             </para>
             <para>
             To check if folder or file supports upload-progress report and resumable upload feature the client application will submit OPTIONS request to that item. If the item implements <c>IUploadProgress</c> interface Engine will add 'resumable-upload' token to DAV response header. See example below.
             </para>
             <para>
             To get information about file upload progress client will submit REPORT request to that file with upload-progress type. The Engine will call <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.UploadProgress"/> property in this case. You will return an array that contains single item (this resource implementing <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload"/>) from <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.UploadProgress"/> method implementation. The engine will extract necessary info from the returned <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload"/> interface and return it to client. The response will contain XML with information about upload progress for the requested file: url of the resource, number or bytes uploaded, total size of the resource and time when last save operation occurred. 
             </para>
             <para>The response returned by server Engine to client is a REPORT multistatus response that contains three properties for each resource:</para>
             <para>
             <list type="bullet">
             <item> <description><b>ithit:bytes-uploaded</b> - integer value. Number of bytes uploaded and saved in persistent storage. If upload was broken or paused the client application will usually start upload from the next byte returned in this property.</description></item>
             <item> <description><b>ithit:last-chunk-saved</b> - date\timein in RFC 1123 format. Indicates when last chunk was saved. May be used in admin applications and automatic maintenance tools to remove files that were not fully uploaded.</description></item>
             <item> <description><b>ithit:total-content-length</b> - integer value. Total file size that is being uploaded to server. Thin client applications may use this value for displaying upload progress.</description></item>
             </list>
             </para>
             <para>See example of upload progress report below.</para>
             <para>
             The client application can also submit upload-progress REPORT request to a folder. In this case from your <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.UploadProgress"/> property implementation you will return array of files that are being uploaded that reside in the folder's subtree. The response XML will contain info about each file from the array in a separate response tag. See example below.
             </para>
             <para>
             If item does not support upload-progress report and server is based on IT Hit WebDAV Server Engine the server will respond with '403 Forbidden' to
             REPORT request. The body will contain &lt;A:supported-report xmlns="DAV:"/>  element. If server does not support REPORT verb you will get 405 Method Not Allowed response.
             </para>
             </remarks>
             <example>
             <para>
             OPTIONS request is used to determine if folder or resource supports resumable upload.
             <para>Request:</para>
             <code>
             <![CDATA[
             OPTIONS /Folder/ HTTP/1.1
             Host: davserver
             Content-Length: 0
             ]]>
             </code>
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 200 OK
             Content-Length: 0
             Accept-Ranges: none
             DAV: 1, 2, resumable-upload
             Public: OPTIONS, PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK
             Allow: OPTIONS, PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK
             ]]>
             </code>
             </para>
             <para>
             Upload progress report submitted over resource contains  info about single item.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: text/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>
             
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 207 Multi-Status
             Content-Length: 2452
             Content-Type: text/xml;charset=UTF-8
            
             <?xml version="1.0" encoding="utf-8" ?>
             <D:multistatus xmlns:D="DAV:">
             <D:response>
                <D:href>http://server:8580/LargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>20</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:29:43 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>150742</ithit:total-content-length>    
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>        
             </D:response>        
            </D:multistatus>
             ]]>
             </code>
             </para>
             <para>
             Upload progress report submitted over folder contains  info about all files being uploaded to subtree.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /folder HTTP/1.1
             Host: http://server:8580/
             Content-Type: text/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>
             
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 207 Multi-Status
             Content-Length: 2452
             Content-Type: text/xml;charset=UTF-8
            
             <?xml version="1.0" encoding="utf-8" ?>
             <D:multistatus xmlns:D="DAV:" xmlns:ithit="ithit">
             <D:response>
                <D:href>http://server:8580/folder/LargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>20</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:29:43 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>150742</ithit:total-content-length>    
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>        
             </D:response>        
             <D:response>
                <D:href>http://server:8580/folder/nestedfolder/AnotherLargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>47</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:16:12 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>6398</ithit:total-content-length>
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>        
             </D:response>        
            </D:multistatus>
             ]]>
             </code>
             </para>
             <para>
             If item on server based on IT Hit WebDAV Server Engine does not support upload-progress the server will respond with 403 Forbidden response.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: text/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>  
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 403 Forbidden
             Content-Length: 31
             Content-Type: text/xml;charset=UTF-8
            
             <supported-report xmlns="DAV"/>
             ]]>
             </code>
             </para>
             <para>
             If server does not support REPORT verb (often non-IT Hit Engine) you will get 405 Method Not Allowed response.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: text/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>  
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 405 Method Not Allowed
             Content-Length: 0
             Content-Type: text/xml;charset=UTF-8
            
             ]]>
             </code>
             </para>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.UploadProgress">
            <summary>
            Array of items that are being uploaded to this item subtree.
            </summary>
            <remarks>
            <para>
            Return array with a single item if implemented on resource items. Return all items that are being uploaded to this subtree if implemented on folder items.
            </para>
            <para>
            Engine calls <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Path"/>, 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.LastChunkSaved"/>, 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.BytesUploaded"/>, 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.TotalContentLength"/> and returns this information to
            client.
            </para>
            </remarks>
            <example>
            <code>
            <![CDATA[
            public class Resource : IResource, IResumableUpload, IUploadProgress
            {
            ...
                IResumableUpload[] IUploadProgress.UploadProgress
                {
                    get
                    {
                        IResumableUpload[] items = new IResumableUpload[1];
                        items[0] = this;
                        return items;
                    }
                }
            ...
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.ResumableUploadModule">
            <summary>
            Enables non-cached upload of files to IIS/ASP.NET.
            </summary>
            <remarks>
            <para>
            Always use this module if you implement resumable upload features and your WebDAV server is hosted in IIS/ASP.NET. It is recommended to use this module even if you do not need any resumable upload fetures but host your server in IIS/ASP.NET.
            </para>
            <para>
            Without this module when a file is being uploaded to server running as ASP.NET application in IIS the file will be first saved to temporary upload folder. Only when entire file is uploaded it becomes available for .NET user code. <see cref="T:ITHit.WebDAV.Server.ResumableUpload.ResumableUploadModule"/> eliminates this 
            problem passing file content directly to Engine. This problem is specific to ASP.NET/IIS and you do not need this module when creating HttpListener-based server.
            </para>
            <para>This module also processes file content submitted to server by thin client (AJAX WebDAV browsers and other) using POST verb. </para>
            <para><b>Note</b>: Always use <see cref="M:ITHit.WebDAV.Server.Engine.Run(System.Web.HttpContext)"/> overloaded method when utilizing this module.</para>
            </remarks>
            <example>
                Example of configuration for IIS:
            <code>
            <![CDATA[
                <httpModules>
            	    <remove name="FileAuthorization"/>
                    <add name="ResumableUploadModule" type="ITHit.WebDAV.Server.ResumableUpload.ResumableUploadModule, ITHit.WebDAV.Server" />
            	</httpModules>
            ]]>
            </code>
            </example>    
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.ResumableUploadModule.Init(System.Web.HttpApplication)">
            <summary>
            Initializes a module and prepares it to handle requests.
            </summary>        
            <param name="context">An <see cref="T:System.Web.HttpApplication"></see> that provides access to the methods, properties, and events common to all application objects within an ASP.NET application </param>
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.ResumableUploadModule.Dispose">
            <summary>
            Disposes of the resources (other than memory) used by the module that implements <see cref="T:System.Web.IHttpModule"></see>.
            </summary>        
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.PostReader.ReadTillSeparatorInChunks(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Boolean)">
            <summary>
            After this method <see cref="F:ITHit.WebDAV.Server.ResumableUpload.PostReader.readCachedData"/> contains cached data right after next boundary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.UploadContext">
            <summary>
            Contains stream of data in case of POST and PUT when <see cref="T:ITHit.WebDAV.Server.ResumableUpload.ResumableUploadModule"/> is used.
            </summary>
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.UploadContext.IsAvailable">
            <summary>
            Determines if <see cref="T:ITHit.WebDAV.Server.ResumableUpload.ResumableUploadModule"/> is used and <see cref="M:ITHit.WebDAV.Server.ResumableUpload.UploadContext.GetStream"/>
            method can be called.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadContext.GetStream">
            <summary>
            Returns content stream of current request.
            </summary>
            <returns>Content stream.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.#ctor(System.Web.HttpWorkerRequest)">
            <summary>   
            Constructor.   
            </summary>   
            <param name="request">The original worker request</param>           
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.ReadEntityBody(System.Byte[],System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetTotalEntityBodyLength">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetPreloadedEntityBody(System.Byte[],System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetPreloadedEntityBody">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetUriPath">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetQueryString">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetRawUrl">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetHttpVerbName">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetHttpVersion">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetRemoteAddress">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetRemotePort">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetLocalAddress">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetLocalPort">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetPreloadedEntityBodyLength">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.ReadEntityBody(System.Byte[],System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetKnownRequestHeader(System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetAppPathTranslated">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.SendStatus(System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.SendKnownResponseHeader(System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.SendUnknownResponseHeader(System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.SendResponseFromMemory(System.Byte[],System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.SendResponseFromFile(System.String,System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.SendResponseFromFile(System.IntPtr,System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.FlushResponse(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.EndOfRequest">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.IsEntireEntityBodyIsPreloaded">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.CloseConnection">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetQueryStringRawBytes">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetRemoteName">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetServerName">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetConnectionID">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetUrlContextID">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetAppPoolID">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetRequestReason">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetUserToken">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetVirtualPathToken">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.IsSecure">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetProtocol">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetFilePath">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetFilePathTranslated">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetPathInfo">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetAppPath">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetUnknownRequestHeader(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetUnknownRequestHeaders">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetServerVariable(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetBytesRead">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.MapPath(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.SendResponseFromMemory(System.IntPtr,System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.SetEndOfSendNotification(System.Web.HttpWorkerRequest.EndOfSendNotification,System.Object)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.SendCalculatedContentLength(System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.SendCalculatedContentLength(System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.HeadersSent">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.IsClientConnected">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetClientCertificate">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetClientCertificateValidFrom">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetClientCertificateValidUntil">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetClientCertificateBinaryIssuer">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetClientCertificateEncoding">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.GetClientCertificatePublicKey">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.MachineConfigPath">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.RootWebConfigPath">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.MachineInstallDirectory">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.RequestTraceIdentifier">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.UploadWorkerRequest.ToString">
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload">
            <summary>
            Implemented by a resource that supports uploading parts of its content.
            </summary>
            <remarks>
            <para>
            You will implement this interface together with <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress"/> interface when you would like to provide one or more of the following features:
            <list type="bullet">
            <item><description>Pause/resume uploads.</description></item>
            <item><description>Restore broken uploads.</description></item>
            <item><description>Report upload process and create upload progress bars.</description></item>
            <item><description>Upload from AJAX (or other thin-client) applications using POST verb.</description></item>
            <item><description>Upload to ASP.NET/IIS-based server files over 2Gb.</description></item>
            <item><description>Non-cached upload in IIS.</description></item>
            </list>
            </para>
            <para>When implementing this interface always configure <see cref="T:ITHit.WebDAV.Server.ResumableUpload.ResumableUploadModule"/> module in your web.config file if your WebDAV server is hosted in IIS/ASP.NET.</para>
            <para>The WebDAV Server Engine can process two types of upload requests:
            <list type="bullet">
            <item><description> <b>PUT upload.</b> Files uploaded via PUT by most RFC 2518 compliant WebDAV clients. Usually only rich client applications, such as .NET and Java can perform upload via PUT. </description></item>
            <item><description> <b>POST upload.</b> Files uploaded via POST verb by AJAX/HTML clients and other thin client applications. </description></item>
            </list>
            </para>
            <para>To provide information about what segment of a file is being uploaded rich client application will attach optional <c>Content-Range: bytes XXX-XXX/XXX</c> header to PUT request. </para>
            <para>Due to modern Internet browsers limitations thin client applications are unable to randomly read file content and upload content using PUT verb. To overcome this limitation the Engine can process files uploaded using POST verb. Thin client applications cannot pause/resume upload or restore broken upload. AJAX client still can display upload progress submitting upload-progress REPORT request (see <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress"/> interface description for more info). </para>
            <para>
            Prior to uploading resource content it is recommended to lock the item. 
            Unless you lock it other users may overwrite content or move/rename the resource.
            </para>
            </remarks>
            <example>The following example demonstrates upload to WebDAV server using POST with multipart encoding. The file will be created in /mydocs/ folder.
            <code>
            <![CDATA[
            <html>
                <head><title>POST Upload to WebDAV Server</title></head>
                <body>
                    <form action="/mydocs/" method="post" enctype="multipart/form-data">
                        <input type="file" name="dummyname" /><br />
                        <input type="submit" />
                    </form>
                </body>
            </html>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.SaveFromStream(System.Int64,System.Int64,System.IO.Stream,System.String)">
             <summary>
             Saves segment of the resource from the specified stream to the WebDAV repository.
             </summary>
             <returns>Instance of <see cref="T:ITHit.WebDAV.Server.Response.WebDAVResponse"/> representing operation status.</returns>
             <param name="totalContentLength">Total size of the resource being uploaded. -1 if size is unknown</param>
             <param name="startIndex">Index in file to which corresponds first byte in <paramref name="segment"/></param>
             <param name="segment">Stream with resource content segment</param>
             <param name="contentType">Content type of the resource</param>
             <returns>
             <list type="bullet">
             <item><description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - the resource content was successfully stored.</description></item>
             <item><description><see cref="T:ITHit.WebDAV.Server.Response.NoContentResponse"/> - the size of the resource content was truncated to zero.</description></item>
             <item><description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - the resource was locked and client did not provide lock token.</description></item>
             <item><description><see cref="T:ITHit.WebDAV.Server.Response.ResumeIncompleteResponse"/> - the upload was not finished.</description></item>
             </list>
             </returns>
             <remarks>
             <para>
             If <paramref name="totalContentLength"/> is -1 the <b>segment</b> parameter
             contains entire resource content.  The <paramref name="startIndex"/> parameter
             is always 0 in this case.
             </para>
             </remarks>
             <example>
             <code>
             <![CDATA[
            public WebDAVResponse SaveFromStream(long startIndex, long totalContentLength, Stream segment, string contentType)
            {
                if (!ClientHasToken)
                    return new LockedResponse();
            
                long read = 0;
                try
                {
                    read = WriteContent(segment, contentType, totalContentLength, startIndex);
                }
                catch (HttpListenerException)
                {
                    //We came here because there were troubles with connection.
                    //We want to keep content but return ResumeIncompleteResponse,
                    //so engine knows we havn't finished uploading.
                }
            
                if (startIndex + read < totalContentLength)
                {
                    return new ResumeIncompleteResponse();
                }
                else if (read > 0)
                {
                    return new OkResponse();
                }
                else
                {
                    return new NoContentResponse();
                }
            }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.CancelUpload">
            <summary>
            In this method implementation you can delete partially uploaded file.
            </summary>
            <returns>
            Instance of <see cref="T:ITHit.WebDAV.Server.Response.WebDAVResponse"/> representing operation status.
            </returns>
            <remarks>
            <para>
            Often during long-continued upload you will keep the old resource 
            content to be returned by GET requests and store the new file content in a
            temporary file (or temporary field in database, etc).  To delete this partially
            uploaded content client can submit CANCELUPLOAD command, the Engine will call this method in this case.
            </para>
            <para>If the item was automatically checked-out by the Engine when upload started it will be automatically checked-in by the Engine after this call.</para>
            </remarks>
            <example>
            Request:
            <code>
            <![CDATA[
            CANCELUPLOAD /LargeFile.doc HTTP/1.1
            Host: http://server:8580/
            ]]>
            </code>
            
            Response:
            <code>
            <![CDATA[
            HTTP/1.1 200 OK
            ]]>
            </code>
            </example>
            <returns>
            <list type="bullet">
            <item>
            <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - upload has been successfully canceled.</description>
            </item>
            <item>
            <description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - this item or its parent was locked and client did not provide lock token.</description>
            </item>        
            </list>
            </returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.LastChunkSaved">
            <summary>
            The date and time when the last chunk of file was saved in your storage.
            </summary>
            <remarks>
            <para>Requested by the Engine during a call to 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.UploadProgress"/>.</para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.BytesUploaded">
            <summary>
            Amount of bytes successfully saved to your storage.
            </summary>
            <remarks>
            <para>Client will use value returned by this property to restore broken upload.
            This value shall always reflect number of bytes already stored to persistent medium.
            </para>
            <para>Requested by the Engine during a call to 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.UploadProgress"/>.</para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.TotalContentLength">
            <summary>
            Total file size that is being uploaded.
            </summary>
            <remarks>
            <para>This value is passed to <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.SaveFromStream(System.Int64,System.Int64,System.IO.Stream,System.String)"/> method. Usually AJAX/HTML based clients will use value returned by this property to display upload progress.</para>
            <para>Requested by the Engine during a call to <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.UploadProgress"/>.</para>
            </remarks>
            <returns>Total file size in bytes.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.CheckInOnFileComplete">
            <summary>
            Indicates if item will be checked-in by the engine when last chunk of a resource is uploaded
            if item was checked in when upload started.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavException">
            <summary>
            
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Constants.Deltav">
            <summary>
            DeltaV constants.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Constants.Deltav.PropertyNames">
            <summary>
            DeltaV Live Properties.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Constants.Deltav.Conditions">
            <summary>
            Pre- and postconditions.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Constants.WebDav">
            <summary>
            WebDAV constants.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Constants.WebDav.PropertyNames">
            <summary>
            WebDAV Live Properties.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.AutoVersion">
             <summary>
             Auto versioning modes supported by item to be used with versioning unaware clients.
             </summary>
             <remarks>
             <para>
             This enumeration determines how engine responds to WebDAV client requests that attempt to modify 
             checked-in items content or properties. Each item that support versioning can function in one of the following 
             auto-versioning modes:
             </para>
             <para>
             <b>NoAutoVersioning Mode.</b>
             In this mode item must be checked-out before modifications. Clients that does not support DeltaV will not be able to modify checked-in items.
             </para>
             <para>
             <b>CheckOutCheckIn Mode.</b>
             In this mode any WebDAV client applications will be able to modify checked-in items on server. Potentially many versions may be created. Workflow for versioning-unaware WebDAV client:
             <list type="number">
             <item><description>Lock request (optional).</description></item>
             <item><description>Modification request: 
             <list type="bullet">
             <item><description>Auto check-out performed.</description></item>
             <item><description>Modifications performed.</description></item>
             <item><description>Auto check-in performed.</description></item>
             </list>
             </description></item>
             <item><description>Unlock request (optional).</description></item>
             </list>
             </para>
             
             <para>
             <b>CheckOutUnlockedCheckIn Mode.</b>
             In this mode any WebDAV client applications will be able to modify checked-in items on server. If WebDAV client locks the item prior to update, the item will be checked in during unlock. This mode reduces the number of versions created by versioning unaware clients. The item is never left checked-out. This mode is recommended if you need to support both Class 1 and Class 2 WebDAV clients. Workflow for versioning-unaware WebDAV client:
             <list type="number">
             <item><description>Lock request (optional).</description></item>
             <item><description>Modification request: 
             <list type="bullet">
                 <item><description>Auto check-out performed.</description></item>
                 <item><description>Modifications performed.</description></item>
                 <item><description>Auto check-in performed if item not locked.</description></item>
             </list>
             </description></item>
             <item><description>Unlock request (optional).
             <list type="bullet">
                 <item><description>Check-in performed.</description></item>
                 <item><description>Unlock performed.</description></item>
             </list>
             </description></item>
             </list>
             </para>
            
             <para>
             <b>CheckOut Mode.</b>
             In this mode any WebDAV client applications will be able to modify checked-in items on server. If the item 
             was not locked before the update it will be left in checked-out state after modifications. Workflow for versioning-unaware WebDAV client:
             <list type="number">
             <item><description>Lock request (optional).</description></item>
             <item><description>Modification request: 
                 <list type="bullet">
                 <item><description>Auto check-out performed.</description></item>
                 <item><description>Modifications performed.</description></item>
                 </list>
             </description></item>
             <item><description>Unlock request (optional). 
                 <list type="bullet">
                 <item><description>Check-in performed.</description></item>
                 <item><description>Unlock performed.</description></item>
                 </list>
             </description></item>
             </list>
             </para>
             
             <para>
             <b>LockedCheckOut Mode.</b>
             Only WebDAV client applications that lock item before the update will be able to modify checked-in item. 
             This mode minimizes amount of versions created by versioning unaware clients. Class 1 WebDAV applications will 
             not be able to modify checked-in items. Workflow for versioning-unaware WebDAV client:
             <list type="number">
             <item><description>Lock request (required).</description></item>
             <item><description>Modification request: 
                 <list type="bullet">
                 <item><description>Auto check-out performed.</description></item>
                 <item><description>Modifications performed.</description></item>
                 </list>
             </description></item>
             <item><description>Unlock request (required). 
                 <list type="bullet">
                 <item><description>Check-in performed.</description></item>
                 <item><description>Unlock performed.</description></item>
                 </list>
             </description></item>
             </list>
             </para>
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.NoAutoVersioning">
            <summary>
            Auto versioning is not supported for checked-in items. Modification requests of versioning unaware clients will
            fail if item was not checked-out.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOutCheckIn">
            <summary>
            Before any item modification (such as changing content or properties) 
            by versioning unaware client  engine will call <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut"/>. After the item is modified
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)"/> will be called.
            <para>
            This potentially can create a lot of versions.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOutUnlockedCheckIn">
            <summary>
            If client tries to modify checked-in item, engine will automatically call
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut"/>. If item is not locked engine
            will call <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)"/> when modification completes.
            <para>
            If item is locked, <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)"/> will be called before the <see cref="M:ITHit.WebDAV.Server.ILock.Unlock(System.String)"/>.
            If lock expires you must check-in item manually.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOut">
            <summary>
            If client tries to modify checked-in item, engine will automatically call
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut"/>. The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)"/> will not be called.
            <para>
            If item is locked, <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)"/> will be called before the <see cref="M:ITHit.WebDAV.Server.ILock.Unlock(System.String)"/>.
            If lock expires you must check-in item manually.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.LockedCheckOut">
            <summary>
            If client tries to modify locked checked-in item, engine will automatically call
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut"/>.
            <para>
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)"/> will be called before the <see cref="M:ITHit.WebDAV.Server.ILock.Unlock(System.String)"/>.
            If lock expires you must check-in item manually.
            </para>
            <para>
            If item is not locked - update request will fail.
            </para>
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IDeltaVItem">
            <summary>
            Base interface for items that support versioning and item versions (DeltaV items).
            </summary>
            <remarks>
            This interface defines properties common to all items that support versioning and item versions. 
            It provides the means of getting and setting comments and author name when creating new version. 
            The author of the version is set and get via <see cref="P:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.CreatorDisplayName"/> property and comment via <see cref="P:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.Comment"/> property.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.Comment">
             <summary>
             Tracks a brief comment about a resource that is suitable for presentation to a user.
             </summary>
             <remarks>
             This property can be used to indicate why that version was created.
             </remarks>
             <value>Comment string.</value>
             <example>
             <code>
            public string Comment
            {
                get
                {
                    string comment;
            
                    using (SqlConnection conn = new SqlConnection(fConnStr))
                    {
                        conn.Open();
                        SqlCommand cmd = conn.CreateCommand();
                        cmd.CommandText = "SELECT Comment FROM Version WHERE VersionId = @VersionId";
                        cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = VersionId;
                        comment = (string)cmd.ExecuteScalar();
                    }
            
                    return comment;
                }
                set
                {
                    using (SqlConnection conn = new SqlConnection(fConnStr))
                    {
                        conn.Open();
                        SqlCommand cmd = conn.CreateCommand();
                        cmd.CommandText = "UPDATE Version SET Comment = @Comment WHERE VersionId = @VersionId";
            
                        cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = this.fVersionId;
                        cmd.Parameters.Add("@Comment", SqlDbType.NVarChar).Value = value;
                        cmd.ExecuteNonQuery();
                    }
                }
            }
             </code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.CreatorDisplayName">
             <summary>
             Display name of the user that created this item.
             </summary>
             <remarks>
             This property contains a description of the creator of the resource that is
             suitable for presentation to a user. Can be used to indicate who created that version.
             </remarks>
             <value>String representing author name.</value>
             <example>
             <code>
            public string CreatorDisplayName
            {
                get
                {
                    string creatorDisplayName;
            
                    using (SqlConnection conn = new SqlConnection(fConnStr))
                    {
                        conn.Open();
                        SqlCommand cmd = conn.CreateCommand();
                        cmd.CommandText = "SELECT CreatorDisplayName FROM Version WHERE VersionId = @VersionId";
                        cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = this.VersionId;
                        creatorDisplayName = (string)cmd.ExecuteScalar();
                    }
            
                    return creatorDisplayName;
                }
                set
                {
                    using (SqlConnection conn = new SqlConnection(fConnStr))
                    {
                        conn.Open();
                        SqlCommand cmd = conn.CreateCommand();
                        cmd.CommandText = "UPDATE Version SET CreatorDisplayName = @CreatorDisplayName"
                                          + " WHERE VersionId = @VersionId";
            
                        cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = this.VersionId;
                        cmd.Parameters.Add("@CreatorDisplayName", SqlDbType.NVarChar).Value = value;
                        cmd.ExecuteNonQuery();
                    }
                }
            }
             </code>
             </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IHistory">
            <summary>
            Contains all versions of a particular version-controlled item.
            </summary>
            <remarks>
            The important property of this interface is <see cref="T:System.IO.Path"/> property inherited from IHierarchyItem. 
            The url returned by this property is used by client applications to remove item from version control. 
            The client application submits DELETE WebDAV request to this url and the engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> 
            passing <b>false</b> as a parameter. In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> you will usually delete all versions. 
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IHistory.CurrentVersion">
            <summary>
            Current item version.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IHistory.VersionSet">
            <summary>
            All versions of current item.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IHistory.RootVersion">
            <summary>
            Item's root version.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IVersion">
             <summary>
             Represents single item version.
             </summary>
             <remarks>
             <para>
             Defines the properties and methods that item version must implement. In addition to methods and properties provided by 
             <see cref="T:ITHit.WebDAV.Server.DeltaV.IDeltaVItem"/> this interface also provides methods for getting version name, next version and previous version. 
             </para>
             <para>
             Usually you will implement <b>IVersion</b> interface for your resource version objects together with <see cref="T:ITHit.WebDAV.Server.IResource"/> interface. 
             While <b>IResource</b> interface is optional for resource versions it may be useful if your DeltaV client application will request 
             content of the resource version. In this case <see cref="M:ITHit.WebDAV.Server.IResource.WriteToStream(System.IO.Stream,System.Int64,System.Int64)"/>, <see cref="P:ITHit.WebDAV.Server.IResource.ContentLength"/> and <see cref="P:ITHit.WebDAV.Server.IResource.ContentType"/> members of the <see cref="T:ITHit.WebDAV.Server.IResource"/> interface will be requested by the engine. 
             Copying, movig, updateng properties and content are not allowed for a version, your <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.CopyTo(ITHit.WebDAV.Server.IFolder,System.String,System.Boolean)"/>, 
             <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.MoveTo(ITHit.WebDAV.Server.IFolder,System.String)"/>, <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(ITHit.WebDAV.Server.Property[],ITHit.WebDAV.Server.Property[])"/> and <see cref="M:ITHit.WebDAV.Server.IResource.SaveFromStream(System.IO.Stream,System.String)"/> 
             implementations must return <see cref="T:ITHit.WebDAV.Server.Response.NotAllowedResponse"/>.
             </para>
             <para>
             Generally from your <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersion.VersionName"/> implementation you can return any string suitable for 
             displaying to user as a version or the hierarchy item. This string must be unique among versions for this hierarchy item. 
             Usually you will return 1, 2, etc or 3.1, 3.4, etc. 
             </para>
             <para>
             <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersion.Successor"/> and <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersion.Predecessor"/> properties of this interface returns next and previous version for the item.
             The <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersion.VersionableItem"/> property returns the hierarchy item (usually resource) to which this version belongs.
             </para>
             </remarks>
             <example>
             <code>
            public class Version : IVersion, IResource
            {
                private Guid fVersionId;
                private Guid fItemId;
                private int fVersionNumber;
            
                private Engine fEngine;
                private string fNameField;
                private string fPath;
                private DateTime fCreatedField;
                private string fConnStr = ConfigurationManager.AppSettings["SqlConnectionString"];
                private static string fRepositoryPath = ConfigurationManager.AppSettings["RepositoryPath"].TrimEnd('\\') + "\\";
                private string fFilePath;
                
                public Version(Engine engine, Guid versionId, Guid itemId,
                    int verNumber, string name, string path, DateTime created)
                {
                    this.fVersionId = versionId;
                    this.fVersionNumber = verNumber;
                    this.fEngine = engine;
                    this.fItemId = itemId;
                    this.fNameField = name;
                    this.fPath = path;
                    this.fCreatedField = created;
                    this.fFilePath = fRepositoryPath + this.fItemId + '\\' + verNumber;
                }
            
                #region IVersion Members
            
                public IVersion Successor
                {
                    get
                    {
                        using (SqlConnection conn = new SqlConnection(fConnStr))
                        {
                            conn.Open();
                            SqlCommand cmd = conn.CreateCommand();
            
                            cmd.CommandText = "SELECT VersionId, VersionNumber, Name, Created"
                                              + " FROM Version"
                                              + " WHERE (ItemId = @ItemId) AND (VersionNumber ="
                                              + " (SELECT MIN(VersionNumber)"
                                              + "   FROM Version"
                                              + "   WHERE (ItemId = @ItemId)"
                                              + "     AND (VersionNumber &gt; @VersionNumber)))";
                            cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                            cmd.Parameters.Add("@VersionNumber", SqlDbType.Int).Value = this.fVersionNumber;
            
                            using (SqlDataReader reader = cmd.ExecuteReader())
                            {
                                if (reader.Read())
                                {
                                    Guid newVersionId = reader.GetGuid(reader.GetOrdinal("VersionId"));
                                    int newVersionNumber = reader.GetInt32(reader.GetOrdinal("VersionNumber"));
                                    string newName = reader.GetString(reader.GetOrdinal("Name"));
                                    DateTime newItemCreated = reader.GetDateTime(reader.GetOrdinal("Created"));
            
                                    string versionPath = CreateVersionPath(fPath.Remove(fPath.IndexOf('?')),
                                                                           newVersionNumber);
            
                                    return new Version(this.fEngine, newVersionId, this.fItemId,
                                                       newVersionNumber, newName, versionPath,
                                                       newItemCreated);
                                }
                            }
                        }
                        return null;
                    }
                }
            
                public IVersion Predecessor
                {
                    get
                    {
                        using (SqlConnection conn = new SqlConnection(fConnStr))
                        {
                            conn.Open();
                            SqlCommand cmd = conn.CreateCommand();
            
                            cmd.CommandText = "SELECT VersionId, VersionNumber, Name, Created"
                                              + " FROM Version"
                                              + " WHERE (ItemId = @ItemId) AND (VersionNumber ="
                                              + " (SELECT MAX(VersionNumber)"
                                              + "   FROM Version"
                                              + "   WHERE (ItemId = @ItemId)"
                                              + "     AND (VersionNumber &lt; @VersionNumber)))";
                            cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                            cmd.Parameters.Add("@VersionNumber", SqlDbType.Int).Value = this.fVersionNumber;
            
                            using (SqlDataReader reader = cmd.ExecuteReader())
                            {
                                if (reader.Read())
                                {
                                    Guid newVersionId = reader.GetGuid(reader.GetOrdinal("VersionId"));
                                    int newVersionNumber = reader.GetInt32(reader.GetOrdinal("VersionNumber"));
                                    string newName = reader.GetString(reader.GetOrdinal("Name"));
                                    DateTime newItemCreated = reader.GetDateTime(reader.GetOrdinal("Created"));
            
                                    string versionPath = CreateVersionPath(fPath.Remove(fPath.IndexOf('?')),
                                                                           newVersionNumber);
            
                                    return new Version(this.fEngine, newVersionId, this.fItemId,
                                                       newVersionNumber, newName, versionPath,
                                                       newItemCreated);
                                }
                            }
                        }
                        return null;
                    }
                }
            
                public IVersionableItem VersionableItem
                {
                    get
                    {
                        string itemPath = fPath.Remove(fPath.IndexOf('?'));
                        return (IVersionableItem)fEngine.GetHierarchyItem(itemPath);
                    }
                }
            
                public string VersionName
                {
                    get { return this.Name + "(V" + this.fVersionNumber + ")"; }
                }
            
                #endregion  // IVersion Members
            
                #region IDeltaVItem Members
            
                public string Comment
                {
                    get
                    {
                        string comment;
            
                        using (SqlConnection conn = new SqlConnection(fConnStr))
                        {
                            conn.Open();
                            SqlCommand cmd = conn.CreateCommand();
                            cmd.CommandText = "SELECT Comment FROM Version WHERE VersionId = @VersionId";
                            cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = VersionId;
                            comment = (string)cmd.ExecuteScalar();
                        }
            
                        return comment;
                    }
                    set
                    {
                        using (SqlConnection conn = new SqlConnection(fConnStr))
                        {
                            conn.Open();
                            SqlCommand cmd = conn.CreateCommand();
                            cmd.CommandText = "UPDATE Version SET Comment = @Comment WHERE VersionId = @VersionId";
            
                            cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = this.fVersionId;
                            cmd.Parameters.Add("@Comment", SqlDbType.NVarChar).Value = value;
                            cmd.ExecuteNonQuery();
                        }
                    }
                }
            
                public string CreatorDisplayName
                {
                    get
                    {
                        string creatorDisplayName;
            
                        using (SqlConnection conn = new SqlConnection(fConnStr))
                        {
                            conn.Open();
                            SqlCommand cmd = conn.CreateCommand();
                            cmd.CommandText = "SELECT CreatorDisplayName FROM Version WHERE VersionId = @VersionId";
                            cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = this.VersionId;
                            creatorDisplayName = (string)cmd.ExecuteScalar();
                        }
            
                        return creatorDisplayName;
                    }
                    set
                    {
                        using (SqlConnection conn = new SqlConnection(fConnStr))
                        {
                            conn.Open();
                            SqlCommand cmd = conn.CreateCommand();
                            cmd.CommandText = "UPDATE Version SET CreatorDisplayName = @CreatorDisplayName"
                                              + " WHERE VersionId = @VersionId";
            
                            cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = this.VersionId;
                            cmd.Parameters.Add("@CreatorDisplayName", SqlDbType.NVarChar).Value = value;
                            cmd.ExecuteNonQuery();
                        }
                    }
                }
            
                #endregion
            
                #region IResource Members
            
                public string ContentType
                {
                    get { return (this.VersionableItem as IResource).ContentType; }
                }
            
                public long ContentLength
                {
                    get
                    {
                        FileInfo file = new FileInfo(this.FilePath);
                        return file.Length;
                    }
                }
            
                public WebDAVResponse WriteToStream(Stream output, long startIndex, long count)
                {
                    long bufSize = 1048576; // 1Mb
            
                    FileInfo file = new FileInfo(fFilePath);
                    byte[] buffer = new byte[bufSize];
            
                    using (FileStream fileStream
                        = file.Open(FileMode.Open, FileAccess.Read, FileShare.Read))
                    {
                        fileStream.Seek(startIndex, SeekOrigin.Begin);
                        int bytesRead;
                        while ((bytesRead = fileStream.Read(buffer, 0, (int)(count > bufSize ? bufSize : count))) > 0)
                        {
                            try
                            {
                                output.Write(buffer, 0, bytesRead);
                            }
                            catch (HttpListenerException ex)
                            {
                                if ((ex.ErrorCode == 1229) || (ex.ErrorCode == 64))
                                {
                                    // client closed connection
                                    // 1. ErrorCode=1229. An operation was attempted on a nonexistent network connection.
                                    // 2. ErrorCode=64. The specified network name is no longer available.
                                    return new OkResponse();
                                }
                                throw;
                            }
                            count -= bytesRead;
                        }
                    }
            
                    return new OkResponse();
                }
            
                public WebDAVResponse SaveFromStream(Stream content, string contentType)
                {
                    return new NotAllowedResponse();
                }
            
                #endregion
            
                #region IHierarchyItem Members
            
                public string Name
                {
                    get { return fNameField; }
                }
            
                public DateTime Created
                {
                    get { return fCreatedField; }
                }
            
                public DateTime Modified
                {
                    get { return DateTime.MinValue; }
                }
            
                public IFolder Parent
                {
                    get { throw new Exception("The method or operation is not implemented."); }
                }
            
                public WebDAVResponse GetProperties(ref Property[] props)
                {
                    using (SqlConnection conn = new SqlConnection(fConnStr))
                    {
                        conn.Open();
            
                        SqlCommand cmd = conn.CreateCommand();
                        cmd.CommandText = "SELECT Name, Namespace, PropVal"
                                          + " FROM VersionProperty"
                                          + " WHERE VersionId = @VersionId";
            
                        cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = fVersionId;
            
                        using (SqlDataReader reader = cmd.ExecuteReader())
                        {
                            if (props == null) // get all properties
                            {
                                List&lt;Property&gt; l = new List&lt;Property&gt;();
                                while (reader.Read())
                                {
                                    Property p = new Property();
                                    p.Name = reader.GetString(reader.GetOrdinal("Name"));
                                    p.Namespace = reader.GetString(reader.GetOrdinal("Namespace"));
                                    p.Value = reader.GetString(reader.GetOrdinal("PropVal"));
                                    l.Add(p);
                                }
                                props = l.ToArray();
                            }
                            else // get selected properties
                            {
                                Property p = new Property();
                                while (reader.Read())
                                {
                                    p.Name = reader.GetString(reader.GetOrdinal("Name"));
                                    p.Namespace = reader.GetString(reader.GetOrdinal("Namespace"));
                                    for (int i = 0; i &lt; props.Length; i++)
                                        if (p.Name == props[i].Name &amp;&amp; p.Namespace == props[i].Namespace)
                                        {
                                            p.Value = reader.GetString(reader.GetOrdinal("PropVal"));
                                            props[i] = p;
                                            break;
                                        }
                                }
                            }
                        }
                    }
            
                    return new OkResponse();
                }
            
                public WebDAVResponse GetPropertyNames(ref Property[] props)
                {
                    return new NotAllowedResponse();
                }
            
                public WebDAVResponse CopyTo(IFolder folder, string destName, bool deep)
                {
                    return new NotAllowedResponse();
                }
            
                public WebDAVResponse MoveTo(IFolder folder, string destName)
                {
                    return new NotAllowedResponse();
                }
            
                public WebDAVResponse Delete()
                {
                    using (SqlConnection conn = new SqlConnection(fConnStr))
                    {
                        conn.Open();
                        SqlCommand cmd = conn.CreateCommand();
            
                        cmd.CommandText = "DELETE FROM Version WHERE VersionId = @VersionId";
                        cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = fVersionId;
                        cmd.ExecuteNonQuery();
                    }
                    File.Delete(this.fFilePath);
            
                    return new NoContentResponse();
                }
            
                public WebDAVResponse UpdateProperties(Property[] setProps, Property[] delProps)
                {
                    return new NotAllowedResponse();
                }
            
                public string Path
                {
                    get { return this.fPath; }
                }
            
                #endregion  // IHierarchyItem Members
            
                public static string CreateVersionPath(string itemPath, int versionNumber)
                {
                    return itemPath + "?version=" + versionNumber;
                }
            
                internal int VersionNumber
                {
                    get { return this.fVersionNumber; }
                }
            
                internal Guid ItemId
                {
                    get { return this.fItemId; }
                }
            
                internal string FilePath
                {
                    get { return this.fFilePath; }
                }
            
                internal Guid VersionId
                {
                    get { return fVersionId; }
                }
            }
             </code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersion.Successor">
            <summary>
            Next version or null if no next version exists.
            </summary>
            <value>Version item representing next version in the list of versions or null if no next version exists.</value>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersion.Predecessor">
            <summary>
            Previous version or null if no previous version exists.
            </summary>
            <value>Version item representing previous version in the list of versions or null if no previous version exists.</value>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersion.VersionableItem">
            <summary>
            Hierarchy item for this version.
            </summary>
            <value>Hierarchy item for this version.</value>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersion.VersionName">
            <summary>
            Name of the version.
            </summary>
            <value>Name of the version.</value>
            <remarks>
            Must be unique among version items for a given hierarchy item. This string is intended for display
            for a user.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IVersionableItem">
            <summary>
            This interface must be implemented on items that support versioning.
            </summary>
            <remarks>
            <para>
            By default items in the repository are not under version control. When item is being put under version control engine calls 
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> method passing <b>true</b> as a parameter. In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> 
            implementation you must create a new version. The content and properties of the new version must be copied from this item. 
            After the call to <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory"/> property must point to the object 
            implementing <see cref="T:ITHit.WebDAV.Server.DeltaV.IHistory"/> interface that will contain single version. The <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckedOut"/> property must return <b>false</b>.
            </para>
            <para>
            <b>If item is under version control it mast always have at last one version in its versions list.</b>
            </para>
            <para>
            After the item had been put under version control client can issue checkout command. In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut"/> 
            implementation you will mark item as checked-out and allow item modifications. When item is in check-out state WebDAV client 
            can issue commands updating item contents and properties.
            </para>
            <para>
            Finally client issues check-in command or discards changes issuing uncheck-out command. In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)"/> 
            implementation you will create a new version. The content and properties of the new version must be copied from this item. 
            The item must be marked as checked-in.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UnCheckOut"/> implementation you will discard changes and restore pre-checkout state. Content and properties must be 
            copied from current version to this item. The item must be marked as checked-in.
            </para>
            <para>
            The typical versioning workflow:
            <list type="number">
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/>. Create new version, copy content and properties from this item to new version.</description></item>
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut"/>. Mark item as checked-out.</description></item>
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.IResource.SaveFromStream(System.IO.Stream,System.String)"/> or <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(ITHit.WebDAV.Server.Property[],ITHit.WebDAV.Server.Property[])"/>. Modify item content and properties.</description></item>
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)"/> or <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UnCheckOut"/>. For <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)"/> - create new version, copy content and properties from this item to new version. For <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UnCheckOut"/> - copy content and properties from current version to this item. Mark item as checked-in.</description></item>
            </list>
            </para>
            <para>
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UpdateToVersion(ITHit.WebDAV.Server.DeltaV.IVersion)"/> implementation you will create a new version and copy content and properties from 
            <see cref="T:ITHit.WebDAV.Server.DeltaV.IVersion"/> passed as a parameter to new version. You will also replace content and properties of this item. 
            The new created version becomes current version. The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UpdateToVersion(ITHit.WebDAV.Server.DeltaV.IVersion)"/> method can only be called when item is in check-in state.
            </para>
            <para>
            When item is being removed from version control engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> method passing <b>false</b> 
            as a parameter. In your implementation you will usually delete all versions. <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory"/> property must return 
            <b>null</b> after this call.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory">
            <summary>
            Current item version history. Null, if item is not under version control.
            </summary>
            <value>Item implementing <see cref="T:ITHit.WebDAV.Server.DeltaV.IHistory"/> interface or null if item is not under version control.</value>
            <remarks>If item is under version control it always has at last one version in its versions list.</remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)">
             <summary>
             Creates new version. Copies all properties and content from this item.
             </summary>
             <param name="newVersionUrl">Url of the newly created version</param>
             <returns>
            	<list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - Operation succeeded.</description>
             </item>
            	</list>
             </returns>
             <remarks>
             <para>
             In your implementation you must create a new version. The content and properties of the new version must be copied from this item. 
             </para>
             <para>
             After the call to this method property <see cref="P:ITHit.WebDAV.Server.DeltaV.IHistory.CurrentVersion"/> must point to the created version.
             </para>
             </remarks>
             <example>
             <code>
            public WebDAVResponse CheckIn(out string newVersionUrl)
            {
                // Create new version. Copy content and properties from this item to new version.
                using (SqlConnection conn = new SqlConnection(fConnStr))
                {
                    conn.Open();
                    SqlCommand cmd = conn.CreateCommand();
            
                    Version version = this.VersionHistory.CurrentVersion as Version;
                    int newVersionNumber = version.VersionNumber + 1;
                    string newVersionPath = Version.CreateVersionPath(this.fPath, newVersionNumber);
            
                    SetResourceCheckedOut(false);
            
                    // Create new version.
                    cmd.CommandText =
                        "SET @Identity = NEWID()"
                        + " INSERT INTO Version"
                        + " (ItemId, VersionId, VersionNumber, Name, Comment,"
                        + " CreatorDisplayName, ContentType, Created)"
                        + " SELECT @ItemId, @Identity, @VersionNumber, Name, Comment,"
                        + " @CreatorDisplayName, ContentType, GETUTCDATE()"
                        + " FROM Item"
                        + " WHERE ItemId = @ItemId";
                    cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                    cmd.Parameters.Add("@VersionNumber", SqlDbType.Int).Value = newVersionNumber;
                    cmd.Parameters.Add("@CreatorDisplayName", SqlDbType.NVarChar).Value = CurrentUserName;
                    SqlParameter idParm = cmd.Parameters.Add("@Identity", SqlDbType.UniqueIdentifier);
                    idParm.Direction = ParameterDirection.Output;
                    cmd.ExecuteNonQuery();
            
                    cmd.Parameters.Clear();
                    cmd.CommandText = "UPDATE Item SET Comment = '' WHERE ItemId = @ItemId";
                    cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
            
                    cmd.ExecuteNonQuery();
            
                    Guid newID = (Guid)idParm.Value;
            
                    // Copy properties to new version
                    cmd.CommandText =
                        "INSERT INTO VersionProperty"
                        + " (VersionId, Name, Namespace, PropVal)"
                        + " SELECT @VersionId, Name, Namespace, PropVal"
                        + " FROM Property"
                        + " WHERE ItemID = @ItemID";
            
                    cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = newID;
                    cmd.ExecuteNonQuery();
            
                    // Copy content to new version
                    File.Copy(this.fFilePath, this.fItemDir + "\\" + newVersionNumber);
                    newVersionUrl = newVersionPath;
                }
                return new OkResponse();
            }
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut">
            <summary>
            Allow modifications to the content and properties of this version-controlled item.
            </summary>
            <returns>
            <list type="bullet">
            <item>
            <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - Operation succeeded.</description>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut"/> implementation you will mark item as checked-out and allow item modifications. 
            When item is in check-out state WebDAV client can issue commands updating item contents and properties.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UnCheckOut">
             <summary>
             Cancels the checkout and restores the pre-checkout state of the version-controlled item.
             </summary>
             <returns>
            	<list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - Operation succeeded.</description>
             </item>
            	</list>
             </returns>
             <remarks>
             In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UnCheckOut"/> implementation you will discard changes and restore pre-checkout state. 
             Content and properties must be copied from current version to this item. The item must be marked as checked-in.
             </remarks>
             <example>
             <code>
            public WebDAVResponse UnCheckOut()
            {
                // Discard changes.
                // Copy content and properties from current version to this item. Mark item as checked in.
                Version version = (Version)this.VersionHistory.CurrentVersion;
            
                using (SqlConnection conn = new SqlConnection(fConnStr))
                {
                    // Restore properties.
                    conn.Open();
                    SqlCommand cmd = conn.CreateCommand();
            
                    cmd.CommandText = "DELETE FROM Property WHERE ItemID = @ItemID";
                    cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                    cmd.ExecuteNonQuery();
            
                    cmd.CommandText = "INSERT INTO Property"
                                      + " (ItemId, Name, Namespace, PropVal)"
                                      + " SELECT @ItemId, Name, Namespace, PropVal"
                                      + " FROM VersionProperty"
                                      + " WHERE VersionId = @VersionId";
            
                    cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = version.VersionId;
                    cmd.ExecuteNonQuery();
            
                    // Restore content.
                    File.Copy(version.FilePath, this.fFilePath, true);
            
                    // Mark item as checked in.
                    SetResourceCheckedOut(false);
                }
            
                return new OkResponse();
            }
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UpdateToVersion(ITHit.WebDAV.Server.DeltaV.IVersion)">
             <summary>
             Updates content and properties of the item to those identified by <paramref name="version"/> parameter.
             </summary>
             <returns>
            	<list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - Operation succeeded.</description>
             </item>
            	</list>
             </returns>
             <para>
             In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UpdateToVersion(ITHit.WebDAV.Server.DeltaV.IVersion)"/> implementation you will create a new version and copy content and properties from 
             <see cref="T:ITHit.WebDAV.Server.DeltaV.IVersion"/> passed as a parameter to new version. You will also replace content and properties of this item. 
             The new created version becomes current version. 
             </para>
             <para>
             The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UpdateToVersion(ITHit.WebDAV.Server.DeltaV.IVersion)"/> method can only be called when item is in check-in state.
             </para>
             <example>
             <code>
            public WebDAVResponse UpdateToVersion(IVersion version)
            {
                // Create a new version and copy content and properties from IVersion passed as a parameter. 
                // Replace content and properties of this item.
                Version ver = version as Version;
                if (ver.ItemId != this.fItemId)
                    return new WebDAVResponse(409, "Conflict");
            
                using (SqlConnection conn = new SqlConnection(fConnStr))
                {
                    conn.Open();
                    SqlCommand cmd = conn.CreateCommand();
            
                    Version currVersion = this.VersionHistory.CurrentVersion as Version;
                    int newVersionNumber = currVersion.VersionNumber + 1;
            
                    // Create a new version
                    cmd.CommandText =
                        "SET @Identity = NEWID()"
                        + " INSERT INTO Version"
                        + " (ItemId, VersionId, VersionNumber, Name, Comment, CreatorDisplayName, ContentType, Created)"
                        +
                        " SELECT @ItemId, @Identity, @VersionNumber, Name, Comment, CreatorDisplayName, ContentType, GETUTCDATE()"
                        + " FROM Item"
                        + " WHERE ItemId = @ItemId";
            
                    cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                    cmd.Parameters.Add("@VersionNumber", SqlDbType.Int).Value = newVersionNumber;
                    SqlParameter idParm = cmd.Parameters.Add("@Identity", SqlDbType.UniqueIdentifier);
                    idParm.Direction = ParameterDirection.Output;
            
                    cmd.ExecuteNonQuery();
                    Guid newID = (Guid)idParm.Value;
            
                    cmd.Parameters.Clear();
            
                    // Copy properties to this item
                    cmd.CommandText = "DELETE FROM Property WHERE ItemID = @ItemID";
                    cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                    cmd.ExecuteNonQuery();
            
                    cmd.CommandText = "INSERT INTO Property"
                                      + " (ItemId, Name, Namespace, PropVal)"
                                      + " SELECT @ItemId, Name, Namespace, PropVal"
                                      + " FROM VersionProperty"
                                      + " WHERE VersionId = @VersionId";
            
                    cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = ver.VersionId;
                    cmd.ExecuteNonQuery();
            
                    // Copy properties to new version
                    cmd.CommandText = "INSERT INTO VersionProperty"
                                      + " (VersionId, Name, Namespace, PropVal)"
                                      + " SELECT @NewVerId, Name, Namespace, PropVal"
                                      + " FROM VersionProperty"
                                      + " WHERE VersionId = @VersionId";
            
                    cmd.Parameters.Clear();
                    cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = ver.VersionId;
                    cmd.Parameters.Add("@NewVerId", SqlDbType.UniqueIdentifier).Value = newID;
                    cmd.ExecuteNonQuery();
            
                    // Copy content to this item
                    File.Copy(ver.FilePath, this.fFilePath, true);
            
                    // Copy content to new version
                    File.Copy(ver.FilePath, this.fItemDir + "\\" + newVersionNumber);
            
                    return new OkResponse();
                }
            }
             </code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.AutoVersion">
            <summary>
            Determines how checked-in item responds to WebDAV client attempts to modify its content or properties.
            </summary>
            <value>One of <see cref="T:ITHit.WebDAV.Server.DeltaV.AutoVersion"/> enum values.</value>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckedOut">
             <summary>
             Determines whether item is in checked-in or checked-out state.
             </summary>
             <value>
             Boolean value indicating if item is in checked-out state.
             </value>
             <example>
             <code>
            public bool CheckedOut
            {
                get
                {
                    bool checkedOut = false;
            
                    SqlCommand cmd = fEngine.CreateNewCommand();
                    cmd.CommandText = "SELECT CheckedOut FROM Item WHERE ItemId = @ItemId";
                    cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = ItemId;
            
                    object o = cmd.ExecuteScalar();
                    if (!(o is DBNull)) checkedOut = (bool)o;
            
                    return checkedOut;
                }
            }
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)">
             <summary>
             Puts or removes current item from version control.
             </summary>
             <returns>
            	<list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - Operation succeeded.</description>
             </item>
            	</list>
             </returns>
             <remarks>
             <para>
             By default items in the repository are not under version control. When item is being put under version control engine calls 
             <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> method passing <b>true</b> as a parameter. In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> 
             implementation you must create a new version. The content and properties of the new version must be copied from this item. 
             After the call to <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory"/> property must point to the object 
             implementing <see cref="T:ITHit.WebDAV.Server.DeltaV.IHistory"/> interface that will contain single version. The <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckedOut"/> property must return <b>false</b>;
             </para>
             <para><b>If item is under version control it mast always have at last one version in its versions list.</b></para>
             <para>
             If <see cref="P:ITHit.WebDAV.Server.Engine.AutoPutUnderVersionControl"/> is <b>true</b> and item is not under version control prior to any item content or properties update <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> will be called.
             </para>
             <para>
             When item is being removed from version control engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> method passing <b>false</b> 
             as a parameter. In your implementation you will usually delete all versions. <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory"/> property must return 
             <b>null</b> after this call.
             </para>
             </remarks>
             <example>
             <code>
            public WebDAVResponse PutUnderVersionControl(bool enable)
            {
                if (enable &amp;&amp; this.VersionHistory == null)
                {
                    // Create new version. The content and properties of the new version is being copied from this item.
                    string autoVerMode = ConfigurationManager.AppSettings["AutoVersionMode"];
                    this.AutoVersion = (AutoVersion)Enum.Parse(typeof(AutoVersion), autoVerMode);
            
                    using (SqlConnection conn = new SqlConnection(fConnStr))
                    {
                        conn.Open();
                        SqlCommand cmd = conn.CreateCommand();
            
                        cmd.CommandText =
                            "SET @Identity = NEWID()"
                            + " INSERT INTO Version"
                            + " (ItemId, VersionId, VersionNumber, Name, Comment, CreatorDisplayName, ContentType, Created)"
                            + " SELECT @ItemId, @Identity, 1, Name, Comment, @CreatorDisplayName, ContentType, GETUTCDATE()"
                            + " FROM Item"
                            + " WHERE ItemId = @ItemId";
            
                        cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                        cmd.Parameters.Add("@CreatorDisplayName", SqlDbType.NVarChar).Value = CurrentUserName;
                        SqlParameter idParam = cmd.Parameters.Add("@Identity", SqlDbType.UniqueIdentifier);
                        idParam.Direction = ParameterDirection.Output;
            
                        cmd.ExecuteNonQuery();
            
                        Guid newID = (Guid)idParam.Value;
            
                        cmd.CommandText =
                            "INSERT INTO VersionProperty"
                            + " (VersionId, Name, Namespace, PropVal)"
                            + " SELECT @VersionId, Name, Namespace, PropVal"
                            + " FROM Property"
                            + " WHERE ItemID = @ItemID";
            
                        cmd.Parameters.Clear();
                        cmd.Parameters.Add("@VersionId", SqlDbType.UniqueIdentifier).Value = newID;
                        cmd.Parameters.Add("@ItemID", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                        cmd.ExecuteNonQuery();
            
                        this.SetResourceCheckedOut(false);
            
                        File.Copy(this.fFilePath, this.fItemDir + "\\1");
                    }
                }
                else if (!enable)
                {
                    // Delete all versions
                    using (SqlConnection conn = new SqlConnection(fConnStr))
                    {
                        conn.Open();
                        SqlCommand cmd = conn.CreateCommand();
            
                        cmd.CommandText = "DELETE FROM Version WHERE ItemId = @ItemId";
                        cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                        cmd.ExecuteNonQuery();
                    }
                    string[] files = Directory.GetFiles(this.fItemDir);
                    foreach (string fileName in files)
                        if (!fileName.EndsWith("current"))
                            File.Delete(fileName);
            
                    return new NoContentResponse();
                }
                return new OkResponse();
            }
             </code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.AutoCheckIn">
             <summary>
             Indicates if item will be checked-in by the engine during the unlock request.
             </summary>
             <remarks>
             Before checking-out the engine sets this property. When item is being unlocked engine reads this property and calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn(System.String@)"/> if necessary. This property is required for auto-versioning.
             </remarks>
             <example>
             <code>
            public bool AutoCheckIn
            {
                set
                {
                    SqlCommand cmd = fEngine.CreateNewCommand();
                    cmd.CommandText = "UPDATE Item"
                                      + " SET CheckinDuringUnlock = @CheckinDuringUnlock"
                                      + " WHERE ItemId = @ItemId";
                    cmd.Parameters.Add("@CheckinDuringUnlock", SqlDbType.Bit).Value = value;
                    cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                    cmd.ExecuteNonQuery();
                }
                get
                {
                    bool result = false;
            
                    SqlCommand cmd = fEngine.CreateNewCommand();
                    cmd.CommandText = "SELECT CheckinDuringUnlock"
                                      + " FROM Item"
                                      + " WHERE ItemId = @ItemId";
                    cmd.Parameters.Add("@ItemId", SqlDbType.UniqueIdentifier).Value = this.fItemId;
                    object obj = cmd.ExecuteScalar();
                    if (obj != null)
                        result = (bool) obj;
            
                    return result;
                }
            }
             </code>
             </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.Engine">
            <summary>
            Serves as the abstract base class for WebDAV engine.
            </summary>
            <remarks>
            <para>
            The Engine class provides the core implementation for WebDAV engine.
            </para>
            <para>
            When you inherit from the <c>Engine</c> class, you must override <see cref="M:ITHit.WebDAV.Server.Engine.GetHierarchyItem(System.String)" /> method.
            In this method you will search for resource, folder, lock-null, version or history item in your storage by path provided
            and return it to WebDAV engine.
            </para>
            <para>
            In each HTTP request you will create separate instance of your class derived 
            from <c>Engine</c> class and call one of its <c>Run</c> overloaded methods. Via <c>Run</c> method parameters engine 
            receives all necessary information about hosting environment. Engine parses XML 
            send by WebDAV client, processes requests making calls to your implementations of 
            WebDAV interfaces (<see cref="T:ITHit.WebDAV.Server.IHierarchyItem" />, <see cref="T:ITHit.WebDAV.Server.IFolder" />, 
            <see cref="T:ITHit.WebDAV.Server.IResource" /> and other) and finally generates XML response.
            </para>
            <para>
            The engine provides 3 overloaded <c>Run</c> methods implementations. Two of them are optimized for use in IIS/ASP.NET-based server and in HttpListener-based server. The third one can be used for running the engine  in virtually any hosting environment.
            </para>
            <para>
            By default WebDAV engine searches for License.lic file in the executing and calling assembly directories.
            To store your license in a different place you must override <see cref="P:ITHit.WebDAV.Server.Engine.License" /> property.
            </para>
            </remarks>
            <threadsafety>Instance members of this class are not thread safe. You must create a separate instance of <see cref="T:ITHit.WebDAV.Server.Engine" /> class for each request.</threadsafety>
            <example>
			IIS/ASP.NET-based server:
			<code>
				<![CDATA[
public class MyHttpHandler : IHttpHandler
{
	...
    public void ProcessRequest(HttpContext context)
    {
        context.Response.BufferOutput = false;

        FileLogger.Level = LogLevel.Debug;
        // always create log file outside of the \bin folder if hosted in IIS\ASP.NET
        FileLogger.LogFile = context.Request.PhysicalApplicationPath + "WebDAVlog.txt";

        MyEngine engine = new MyEngine();
        engine.Run(HttpContext.Current);
    }
	...
}
				]]>
			</code>
		</example>
            <example>
            <para>HttpListener-based server:</para>
            <para>For asynchronous HttpListener server implementation see example in <see cref="M:ITHit.WebDAV.Server.Engine.Run(System.Net.HttpListenerContext,System.Net.HttpListenerPrefixCollection)" /> method description.</para>
            <code>
            class Program
            {
            	static void Main(string[] args)
            	{
            		HttpListener listener = new HttpListener();
            		listener.Prefixes.Add("http://localhost:8080/");
            		listener.Start();
            		while (true)
            		{
            			MyEngine engine = new MyEngine();
            			HttpListenerContext context = listener.GetContext();
            			engine.Run(context, listener.Prefixes);
            			try
            			{
            				context.Response.Close();
            			}
            			catch
            			{
            				// client closed connection before the content was sent
            			}
            		}
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Engine.RegisterMethodHandler(System.String,ITHit.WebDAV.Server.IMethodHandler)">
            <summary>
            Registers custom method handler.
            </summary>
            <param name="method">HTTP verb</param>
            <param name="handler">Custom handled implementing <see cref="T:ITHit.WebDAV.Server.IMethodHandler" /> interface</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Using this method you can register custom method handler to be caller by the engine. If the handler for the specified method was already defined it is returned from this method. The original handler can be saved and called later from your custom handler.
            </remarks>
            <example>
			The WebDAV protocol does not regulate GET request to a WebDAV collection (folder). The following sample demonstrates custom handler for GET request submitted to folder item. The custom handler returns HTML page for folder while calling the original handler for any other items.
			<code>
				<![CDATA[
WDEngine engine = new WDEngine();
// set custom handler to process GET requests to folders
MyCustomGetHandler handler = new MyCustomGetHandler();
handler.OriginalHandler = engine.RegisterMethodHandler("GET", handler);
engine.Run(request, response);

class MyCustomGetHandler : IMethodHandler
{
    private IMethodHandler originalHandler;

    public IMethodHandler OriginalHandler
    {
        set { originalHandler = value; }
    }

    public void ProcessRequest(Request request, IResponse response, IHierarchyItem item)
    {
        if(item is IFolder)
            HttpContext.Current.Response.TransmitFile(HttpContext.Current.Request.PhysicalApplicationPath + "MyCustomHandlerPage.html");
        else
            originalHandler.ProcessRequest(request, response, item);
    }
}
				]]>
			</code>
		</example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Engine.GetHierarchyItem(System.String)">
            <summary>
            Implementation of this abstract method is used by WebDAV engine to find hierarchy item objects by path.
            </summary>
            <param name="path">
            Path of the hierarchy item object.
            It is always the full path from the root of the WebDAV repository.
            </param>
            <returns>
            Hierarchy item object referenced by the specified path or <c>null</c>
            if hierarchy item not found.
            </returns>
            <remarks>
            <para>
            When you inherit from the <c>Engine</c> class, you must override this abstract method.
            For WebDAV Class 1 server in this method implementation you will search for resource or folder in your storage by path provided
            and return it to WebDAV engine. For WebDAV Class 2 server you will return folder, resource or lock-null item. 
            For DeltaV server in addition to folder, resource or lock-null item you will return version and history items.
            </para>
            </remarks>
            <example>
            <code>
            public class MyEngine : Engine
            {
            	public override IHierarchyItem GetHierarchyItem(string path)
            	{
            		FileLogger.WriteMessage("Url  path = " + path, LogLevel.Debug);
            		string discPath = ConfigurationManager.AppSettings["StorageRootFolder"].TrimEnd('\\');
            		discPath += path.Replace('/', '\\');
            		FileLogger.WriteMessage("Disc path = " + discPath, LogLevel.Debug);
                       
            		DirectoryInfo directory = new DirectoryInfo(discPath);
            		if(directory.Exists)
            			return new Folder(directory);
            		else
            		{
            			FileInfo file = new FileInfo(discPath);
            			if(file.Exists)
            			{
            				if ( (file.Attributes &amp; FileAttributes.Temporary) == 0)
            					return new Resource(file);
            				else
            					return new LockNull(file);
            			}
            		}
            		return null;
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Engine.GetHierarchyItemAndName(System.String,System.String,System.String@)">
            <summary>
            Implementation of this abstract method is used by WebDAV engine to find hierarchy item objects by path
            and to convert name of new hierarchy item to allowed format.
            </summary>
            <param name="path">
            Path of the hierarchy item object.
            It is always the full path from the root of the WebDAV repository.</param>
            <param name="name">
            Name of the new hierarchy item.</param>
            <param name="outName">Name of the new hierarchy item in allowed format.</param>
            <returns>Hierarchy item object referenced by the specified path or <c>null</c>
            if hierarchy item not found (in the latter case the outName is null).</returns>
            <seealso cref="M:ITHit.WebDAV.Server.Engine.GetHierarchyItem(System.String)"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)">
            <summary>
            Processes WebDAV request and generates WebDAV response.
            </summary>
            <param name="request">
            Instance of your request class derived from <see cref="P:ITHit.WebDAV.Server.Engine.Request"/> class.
            </param>
            <param name="response">
            Your <see cref="T:ITHit.WebDAV.Server.IResponse"/> interface implementation.
            </param>
            <remarks>
            <para>
            You can use this overloaded method instance if you host your server in any environment other then IIS / ASP.NET or HttpListener. If you host your server in IIS / ASP.NET or in HttpListener use other overloaded <c>Run</c> methods.
            </para>
            <para>
            You must call Run method in each request to your WebDAV server passing your 
            request and response classes derived from <see cref="T:ITHit.WebDAV.Server.Request"/> and <see cref="T:ITHit.WebDAV.Server.IResponse"/> as input parameters. 
            </para>
            </remarks>
            <example>
            <code>
            MyEngine engine = new MyEngine();
            MyRequest request = new MyRequest();
            MyResponse response = new MyResponse();
            engine.Run(request, response);
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Engine.Run(System.Web.HttpContext)">
            <summary>
            Processes WebDAV request and generates WebDAV response for IIS/ASP.NET-based server.
            </summary>
            <param name="context">An ASP.NET <c>HttpContext</c> object</param>
            <remarks>
            <para>
            You must call Run method in each request to your WebDAV server passing ASP.NET context.
            </para>
            <para>
            This method instance is optimized for processing requests in IIS/ASP.NEt-based server. If you host your server in HttpListener use this <see cref="M:ITHit.WebDAV.Server.Engine.Run(System.Net.HttpListenerContext,System.Net.HttpListenerPrefixCollection)" /> overloaded instance instead.
            </para>
            </remarks>
            <example>
			IIS/ASP.NET-based server:
			<code>
				<![CDATA[
public class MyHttpHandler : IHttpHandler
{
	...
    public void ProcessRequest(HttpContext context)
    {
        context.Response.BufferOutput = false;

        FileLogger.Level = LogLevel.Debug;
        // always create log file outside of the \bin folder if hosted in IIS\ASP.NET
        FileLogger.LogFile = context.Request.PhysicalApplicationPath + "WebDAVlog.txt";

        MyEngine engine = new MyEngine();
        engine.Run(HttpContext.Current);
    }
	...
}
				]]>
			</code>
		</example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Engine.Run(System.Net.HttpListenerContext,System.Net.HttpListenerPrefixCollection)">
             <summary>
             Processes WebDAV request and generates WebDAV response for HttpListener-based server.
             </summary>
             <param name="context">An HttpListenerContext object</param>
             <param name="prefixes">List of HttpListener prefixes</param>
             <remarks>
             <para>
             You must call Run method in each request to your WebDAV server passing listener context and list of HttpListener prefixes.
             </para>
             <para>
             This method instance is optimized for processing requests in HttpListener. If you host your server in IIS/ASP.NET use this <see cref="M:ITHit.WebDAV.Server.Engine.Run(System.Web.HttpContext)"/> overloaded instance instead.
             </para>
             </remarks>
             <example>
             <code>
            	static void Main(string[] args)
            	{
            		string uriPrefix = ConfigurationManager.AppSettings["ListenerPrefix"];
            		HttpListener listener = new HttpListener();
            		listener.Prefixes.Add(uriPrefix);
            		listener.Start();
            		while (true)
            		{
            			IAsyncResult result = listener.BeginGetContext(new AsyncCallback(ListenerCallback), listener);
            			result.AsyncWaitHandle.WaitOne();
            		}
            	}
            
            	public static void ListenerCallback(IAsyncResult result)
            	{
            		HttpListener listener = (HttpListener)result.AsyncState;
            		HttpListenerContext context = listener.EndGetContext(result);
            		WDEngine engine = new WDEngine(context.User);
            		engine.Run(context, listener.Prefixes);
            		try
            		{
            			context.Response.Close();
            		}
            		catch
            		{
            			// client closed connection before the content was sent
            		}
            	}
             </code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.Engine.License">
            <summary>
            Gets the license text from the default location.
            </summary>
            <value>
            License string
            </value>
            <remarks>
            By default IT Hit WebDAV engine searches for License.lic in the executing and calling assembly directories (in the folder where your .dll or .exe file resides). 
            To store your license in a different place (registry, database, etc) you should override License property
            and return the license text from this property. You can also hardcode the license text in your code.
            In this case you do not need any additional files when redistributing your application.
            <para>
            Make sure you do not make any changes in Data and Signature tags as 
            license validation will fail in this case.
            </para>
            </remarks>
            <example>
            <code>
            public class MyEngine : Engine
            {
            	...
            	public override string License
            	{
            		get
            		{
            			TextReader reader = File.OpenText(
            				HttpContext.Current.Request.PhysicalApplicationPath + "License.lic");
            			string license = reader.ReadToEnd();
            			reader.Close();
            			return license;
            		}
            	}
            	...
            }
            </code>
            </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.Engine.Request">
            <summary>
            <c>Request</c> passed to <c>Run</c> method.
            </summary>
            <value>
            <see cref="P:ITHit.WebDAV.Server.Engine.Request"/> object passed to <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)"/> method. <c>Null</c> before <c>Run</c> is called.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Engine.Response">
            <summary>
            <c>IResponse</c> passed to <c>Run</c> method.
            </summary>
            <value>
            <see cref="T:ITHit.WebDAV.Server.IResponse"/> interface passed to <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)"/> method. <c>Null</c> before <c>Run</c> is called.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Engine.CalculateContentLength">
            <summary>
            Indicates if response content length calculation will occur.
            </summary>
            <value>
            Boolean value indicating if content length will be calculated in <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)" /> method. Default is <b>true</b>.
            </value>
            <remarks>
            <para>If this property is set to <b>true</b> engine will calculate output content length and set <see cref="P:ITHit.WebDAV.Server.IResponse.ContentLength"/> property before returning from <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)"/> method. If you would like to send chunked responses you must set this property to <b>false</b>.
            <para>ASP.NET will send chunked responses only to <b>GET</b> verb if <b>HttpContext.Current.Response.BufferOutput = false</b> and request is HTTP 1.1. Responses to all other verbs will not be chunked.</para>
            <para>To send chunked responses from <b>HttpListener</b> you must set this property to false and set <b>HttpListenerContext.Response.SendChunked = true</b>. If <b>SendChunked=false</b> and <b>CalculateContentLength=false</b> than <b>HttpListener</b> will not send any response because the content length will be unknown.</para>
            <para>Responses must not include both <b>Content-Length</b> header and <b>Transfer-Encoding: chunked</b> header. If server is sending chunked response client application will not be able to detect content length. Downloading a large file using download manager client will not be able to see the entire content length and evaluate time required for download.</para>
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Engine.AutoPutUnderVersionControl">
            <summary>
            Determines if placing resource under version control is automatic.
            </summary>
            <remarks>
            <value>Boolean value indicating if items must be put under version control before content or properties update. Default is <b>true</b>.</value>
            <para>
            Determines whether resources will be placed under version control automatically
            or explicit request from client shall be made to put a resource under version control.
            </para>
            <para>
            If this property is <c>true</c> the <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> will be called after item is created and prior item content or properties update.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Engine.IgnoreExceptions">
             <summary>
             Determines if instance of <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)"/> method should suppress any exceptions.
             </summary>
             <value>
             Boolean value indicating if <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)"/> should suppress any exceptions. Default value is  <c>true</c>.
             </value>
             <remarks>
             Set this property to <c>false</c> to catch exceptions thrown by <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)"/> method. 
             </remarks>
             <example>
             In this example the transaction is opened before calling any WebDAV Engine methods. 
             If any exception occurs in any interface implementation the transaction is rolled back.
             <code>
            public void ThreadProc()
            {
                string uriPrefix = ConfigurationManager.AppSettings["ListenerPrefix"];
                HttpListener listener = new HttpListener();
                listener.Prefixes.Add(uriPrefix);
            
                string authType = ConfigurationManager.AppSettings["AuthenticationType"];
                switch (authType)
                {
                    case "Ntlm":
                        listener.AuthenticationSchemes = AuthenticationSchemes.Ntlm;
                        break;
                    case "Basic":
                        listener.AuthenticationSchemes = AuthenticationSchemes.Basic;
                        break;
                    case "None":
                        listener.AuthenticationSchemes = AuthenticationSchemes.Anonymous;
                        break;
                }
            
                listener.Start();
                while (listening)
                {
                    IAsyncResult result = listener.BeginGetContext(new AsyncCallback(ListenerCallback), listener);
                    result.AsyncWaitHandle.WaitOne();
                }
            }
            
            public static void ListenerCallback(IAsyncResult result)
            {
                HttpListener listener = (HttpListener)result.AsyncState;
                HttpListenerContext context = listener.EndGetContext(result);
                WDEngine engine = new WDEngine(context.User);
                engine.IgnoreException = false; // if any exception during Engine.Run call occurs exception will be thrown
            
                if (UserAutorized(context, listener))
                {
                    try
                    {
                        using (TransactionScope scope = new TransactionScope())
                        {
                            engine.Run(context, listener.Prefixes);
                            scope.Complete();
                        }
                    }
                    catch
                    {
                        // error during request processing occurred, transaction rolled back, continue listening
                    }
                }
                else
                    context.Response.StatusCode = 401;
            
                if (response.StatusCode == 401)
                    ShowLoginDialog(context, response, listener);
            
                try
                {
                    context.Response.Close();
                }
                catch
                {
                    // client closed connection before the content was sent
                }
            }
            
            private static void ShowLoginDialog(HttpListenerContext context, WDResponse response, HttpListener listener)
            {
                switch (listener.AuthenticationSchemes)
                {
                    case AuthenticationSchemes.Ntlm:
                        response.AddHeader("WWW-Authenticate", "NTLM");
                        byte[] message = new UTF8Encoding().GetBytes("Access denied");
                        context.Response.OutputStream.Write(message, 0, message.Length);
                        break;
                    case AuthenticationSchemes.Basic:
                        context.Response.AddHeader("WWW-Authenticate",
                                                   "Basic Realm=\"My WebDAV Server\"");
                        message = new UTF8Encoding().GetBytes("Access denied");
                        context.Response.ContentLength64 = message.Length;
                        context.Response.OutputStream.Write(message, 0, message.Length);
                        break;
                }
            }
             </code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.Engine.AllowOffice12Versioning">
            <exclude />
        </member>
        <member name="P:ITHit.WebDAV.Server.Engine.Version">
            <exclude />
        </member>
        <member name="P:ITHit.WebDAV.Server.Engine.LinkerTimestamp">
            <exclude />
        </member>
        <member name="P:ITHit.WebDAV.Server.Engine.ContentEncoding">
            <summary>
            Gets or sets the HTTP character set of the output stream.
            </summary>
            <value>A <c>Encoding</c> object that contains information about the character set of the response. Default is UTF-8.</value>
        </member>
        <member name="T:ITHit.WebDAV.Server.FilterStreamInput">
            <summary>
            Logs input content.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.FilterStreamOutput">
            <summary>
            Calculates content length ang logs output content.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.IFolder">
             <summary>
             Represents a folder in the WebDAV repository.
             </summary>
             <remarks>
             Defines the properties and methods that WebDAV server folder objects must implement.
             In addition to methods and properties provided by <see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/> this interface also provides
             methods for creating WebDAV items (folders and resources) and enumerating its children.
             </remarks>
             <example>
             <code>
            	public class Folder : HierarchyItem, IFolder, IFolderLock
            	{
            		public Folder(DirectoryInfo directory)
            			: base(directory)
            		{
            		}
            
            		#region IFolder Members
            
            		public IHierarchyItem[] Children
            		{
            			get
            			{
            				ArrayList children = new ArrayList();
            
            				DirectoryInfo directory = (DirectoryInfo)fileSystemInfo;
            				FileSystemInfo[] aFSI = directory.GetFileSystemInfos();
            				foreach(FileSystemInfo item in aFSI)
            				{
            					if (item is DirectoryInfo)
            						children.Add(new Folder((DirectoryInfo)item));
            					else
            					{
            						if( (item.Attributes &amp; FileAttributes.Temporary)!=0 )
            							children.Add(new LockNull((FileInfo)item));
            						else
            							children.Add(new Resource((FileInfo)item));
            					}
            				}
            
            				return (IHierarchyItem[])children.ToArray(typeof(IHierarchyItem));
            			}
            		}
            
                 public WebDAVResponse CreateResource(string name)
                 {
                    DirectoryInfo directory = (DirectoryInfo)fileSystemInfo;
            
                     using(FileStream fileStream = new FileStream(
                             directory.FullName + "\\" + name, FileMode.CreateNew))
                        {
                        }
            
                     return new CreatedResponse();
                 }
            
            		public WebDAVResponse CreateFolder(string name)
            		{
            			DirectoryInfo directory = (DirectoryInfo)fileSystemInfo;
            			directory.CreateSubdirectory(name);
            			return new CreatedResponse();
            		}
            		#endregion
            
            		#region IFolderLock Members
            
            		public WebDAVResponse CreateLockNull(string name, ref LockInfo lockInfo)
            		{
            			DirectoryInfo directory = (DirectoryInfo)fileSystemInfo;
            			FileInfo file = new FileInfo(directory.FullName + "\\" + name);
            			FileStream fileStream = file.Create();
            			file.Attributes |= FileAttributes.Temporary; // mark as lock-null item
            			fileStream.Close();
            			return new CreatedResponse();
            		}
            
            		#endregion
            
            		public override WebDAVResponse Delete()
            		{
            			((DirectoryInfo)fileSystemInfo).Delete(true);
            			return new NoContentResponse();
            		}
            	}
            	</code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IFolder.Children">
             <summary>
             Gets the array of this folder's children.
             </summary>
             <value>
             Array of <see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/> objects. Each item is a resource, folder or lock-null item.
             </value>
             <example>
             <code>
            	public IHierarchyItem[] Children
            	{
            		get
            		{
            			ArrayList children = new ArrayList();
            
            			DirectoryInfo directory = (DirectoryInfo)fileSystemInfo;
            			FileSystemInfo[] aFSI = directory.GetFileSystemInfos();
            			foreach(FileSystemInfo item in aFSI)
            			{
            				if (item is DirectoryInfo)
            					children.Add(new Folder((DirectoryInfo)item));
            				else
            				{
            					if( (item.Attributes &amp; FileAttributes.Temporary)!=0 )
            						children.Add(new LockNull((FileInfo)item));
            					else
            						children.Add(new Resource((FileInfo)item));
            				}
            			}
            
            			return (IHierarchyItem[])children.ToArray(typeof(IHierarchyItem));
            		}
            	}
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IFolder.CreateResource(System.String)">
             <summary>
             Creates new WebDAV resource with the specified name in this folder.
             </summary>
             <param name="name">Name of the resource to create</param>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.CreatedResponse"/> - a new resource was created.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - this folder was locked. Client did not provide the lock token.</description>
             </item>
             </list>
             </returns>
             <remarks>You must create a resource in your repository during this call. After calling this method Engine calls <see cref="M:ITHit.WebDAV.Server.IResource.SaveFromStream(System.IO.Stream,System.String)">IResource.SaveFromStream</see> or <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.SaveFromStream(System.Int64,System.Int64,System.IO.Stream,System.String)">IResumableUpload.SaveFromStream</see>.</remarks>
             <example>
             <code>
                 public WebDAVResponse CreateResource(string name)
                 {
                    DirectoryInfo directory = (DirectoryInfo)fileSystemInfo;
            
                     using(FileStream fileStream = new FileStream(
                             directory.FullName + "\\" + name, FileMode.CreateNew))
                        {
                        }
            
                     return new CreatedResponse();
                 }
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IFolder.CreateFolder(System.String)">
             <summary>
             Creates new WebDAV folder with the specified name in this folder.
             </summary>
             <param name="name">Name of the folder to create</param>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.CreatedResponse"/> - a new folder was created.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - this folder was locked. Client did not provide the lock token.</description>
             </item>
             </list>
             </returns>
             <example>
             <code>
            	public WebDAVResponse CreateFolder(string name)
            	{
            		if(!ClientHasToken)
            			return new LockedResponse();
            
            		SqlConnection conn = new SqlConnection(connStr);
            		SqlTransaction trans = null;
            		conn.Open();
            		try
            		{
            			trans = conn.BeginTransaction();
            			CreateChild(trans, name, ItemType.Folder);
            			trans.Commit();
            		}
            		catch(Exception ex)
            		{
            			if(trans != null) trans.Rollback();
            			throw;
            		}
            		finally
            		{
            			conn.Close();
            		}
            		return new CreatedResponse();
            	}
             </code>
             </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.IFolderLock">
            <summary>
            Defines the properties and methods that folder objects of WebDAV Class 2 compliant server must implement.
            </summary>
            <remarks>
            <para>
            To create DAV Class 2 compliant server you must implement this interface on folder items. In addition to methods and properties provider by <see cref="T:ITHit.WebDAV.Server.ILock"/> this interface also provides method for creating lock-null items. The lock-null items are created before folders and resources creation. WebDAV client creates lock-null item with a specified name and than converts it to a resource or folder. However client can also issue folder and resource creation requests without creating lock-null item.
            </para>
            <para>
            A lock-null item can not be moved, copied or deleted. It must return <see cref="T:ITHit.WebDAV.Server.Response.NotAllowedResponse"/> from <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.CopyTo(ITHit.WebDAV.Server.IFolder,System.String,System.Boolean)"/>, <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.MoveTo(ITHit.WebDAV.Server.IFolder,System.String)"/>, <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.Delete"/> and <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(ITHit.WebDAV.Server.Property[],ITHit.WebDAV.Server.Property[])"/> implementations. If the item was not converted to a resource or folder and WebDAV client issues unlock request with appropriate lock token the item must be deleted.
            </para>
            <para>
            A lock-null item must not appear among <see cref="P:ITHit.WebDAV.Server.IFolder.Children"/> items of the folder where it was created.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.IFolderLock.CreateLockNull(System.String,ITHit.WebDAV.Server.LockInfo@)">
             <summary>
             Reserves new item name for future use.
             </summary>
             <param name="newItemName">Name of the new item to reserve</param>
             <param name="lockInfo">Describes a lock on the new item</param>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.CreatedResponse"/> - the lock request succeeded. Lock-null item was created.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - this folder was locked and client did not provide lock token,
             or lock-null item with the specified name exists in this folder.</description>
             </item>
             </list>
             </returns>
             <remarks>
             <para>
             <c>CreateLockNull</c> method can be called before creating new folders and resources. This method reserves name of a resource or folder. In your <c>CreateLockNull</c> you must create a new lock-null item.
             </para>
             <para>
             WebDAV engine passes <see cref="T:ITHit.WebDAV.Server.LockInfo"/> structure to this method by reference. All fields of the structure are provided by WebDAV client except <see cref="F:ITHit.WebDAV.Server.LockInfo.Token"/> field. In your <c>CreateLockNull</c> implementation you must create lock token and set <see cref="F:ITHit.WebDAV.Server.LockInfo.Token"/> member. You must also associate generated token with the new lock-null item in the repository during this call. The token is sent to the WebDAV client.
             </para>
             </remarks>
             <example>
             <code>
            	public WebDAVResponse CreateLockNull(string newItemName, ref LockInfo lockInfo)
            	{
            		LockInfo[] locks = ActiveLocks;
            		if(locks.Length > 0)
            		{
            			for(int i=0;i&lt;locks.Length;i++)
            				if(locks[i].Deep &amp;&amp; (!lockInfo.Shared || !locks[i].Shared))
            					return new LockedResponse();
            
            			if(!ClientHasToken)
            				return new LockedResponse();
            		}
            		SqlConnection conn = new SqlConnection(connStr);
            		SqlTransaction trans = null;
            		conn.Open();
            		HierarchyItem newItem;
            		try
            		{
            			trans = conn.BeginTransaction();
            			newItem = CreateChild(trans, newItemName, ItemType.LockNull);
            			trans.Commit();
            		}
            		catch(Exception ex)
            		{
            			if(trans != null) trans.Rollback();
            			throw;
            		}
            		finally
            		{
            			conn.Close();
            		}
            		newItem.Lock(ref lockInfo);
            
            		return new CreatedResponse();
            	}
            
            	public WebDAVResponse Lock(ref LockInfo lockInfo)
            	{
            		...
            		lockInfo.Token = Guid.NewGuid().ToString();
            		...
            	}
             </code>
             </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.IHierarchyItem">
            <summary>
            Represents one item (resource, folder or lock-null) in the WebDAV repository.
            </summary>
            <remarks>
            Defines the properties and methods common to all WebDAV folders and resources.
            <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Created"/> and <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Modified"/> properties must return Universal Coordinated Time (UTC).
            <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.GetProperties(ITHit.WebDAV.Server.Property[]@)"/> and <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(ITHit.WebDAV.Server.Property[],ITHit.WebDAV.Server.Property[])"/> are called when WebDAV client is reading, adding, updating or deleting properties.
            This interface also provides methods for managing hierarchy: moving, copying and deleting WebDAV items.
            See <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.CopyTo(ITHit.WebDAV.Server.IFolder,System.String,System.Boolean)"/>, <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.MoveTo(ITHit.WebDAV.Server.IFolder,System.String)"/> and <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.Delete"/> methods.
            Your resource items must implement <see cref="T:ITHit.WebDAV.Server.IResource"/> interface, folder items - <see cref="T:ITHit.WebDAV.Server.IFolder"/> interface. Class 2 server lock-null items must implement <see cref="T:ITHit.WebDAV.Server.ILockNull"/> interface.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItem.Name">
            <summary>
            Gets the name of the item in repository.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItem.Parent">
             <summary>
             Gets the parent folder of the item in repository (<c>null</c> for the root of the repository).
             </summary>
             <example>
             <code>
            	public abstract class HierarchyItem : IHierarchyItem, ILock
            	{
            		protected FileSystemInfo fileSystemInfo;
            
            		public HierarchyItem(FileSystemInfo fileSystemInfo)
            		{
            			this.fileSystemInfo = fileSystemInfo;
            		}
            
            		public IFolder Parent
            		{
            			get
            			{
            				string storageRootFolder = ConfigurationManager.AppSettings["StorageRootFolder"].TrimEnd('\\');
            				string parentPath = fileSystemInfo.FullName.TrimEnd('\\');
            				int index = parentPath.LastIndexOf('\\');
            				if (index &lt;= storageRootFolder.Length-1)
            					return null;
            				DirectoryInfo directory = new DirectoryInfo(parentPath.Remove(index));
            				return new Folder(directory);
            			}
            		}
            		...
            	}
            	</code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItem.Created">
            <summary>
            Gets the creation date of the item in repository expressed as the coordinated universal time (UTC).
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItem.Modified">
            <summary>
            Gets the last modification date of the item in repository expressed as the coordinated universal time (UTC).
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.CopyTo(ITHit.WebDAV.Server.IFolder,System.String,System.Boolean)">
             <summary>
             Creates a copy of this item with a new name in the destination folder.
             </summary>
             <param name="folder">Destination folder</param>
             <param name="destName">Name of the destination item</param>
             <param name="deep">Indicates whether to copy entire subtree</param>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.CreatedResponse"/> - the copy operation resulted in the creation of a new item.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.NoContentResponse"/> - the source item was successfully copied to a pre-existing destination item.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.ConflictResponse"/> - destination folder does not exist.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - the destination item was locked and client did not provide lock token.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.MultistatusResponse"/> - errors has occured during processing of the subtree. Each <see cref="T:ITHit.WebDAV.Server.Response.ItemResponse"/> must contain info for every item that was successfully copied or failed to copy.</description>
             </item>
             </list>
             </returns>
             <remarks>
             <para>
             If error occurred while copying resource located in a subtree, the server 
             should try to continue copy operation and copy all other items. In this case 
             you must return MultistatusResponse that contain separate ItemResponse for 
             every item that was successfully copied or failed to copy.
             </para>
             <para>
             A CopyTo method invocation must not copy any locks active on the source item.
             However, if this method copies the item into a folder that has a deep lock,
             then the destination item must be added to the lock.
             </para>
             </remarks>
             <example>
             Example of <c>CopyTo</c> implementation for WebDAV Class 2 server:
             <code>
             public class Folder : HierarchyItem, IFolder, IFolderLock
             {
            		...
            		public override WebDAVResponse CopyTo(IFolder folder, string destName, bool deep)
            		{
            			Folder destFolder = folder as Folder;
            			if(destFolder == null)
            				return new ConflictResponse();
            			if(!destFolder.ClientHasToken)
            				return new LockedResponse();
            
            			IHierarchyItem destItem = destFolder.FindChild(destName);
            			Folder newDestFolder;
                        
            			if(destItem != null)
            			{
            				if(destItem is IResource)
            				{
            					WebDAVResponse delResp = destItem.Delete();
            					if(!delResp.IsSuccess)
            						return delResp;
            					newDestFolder = CopyThisItem(destFolder, null, destName);
            				}
            				else
            				{
            					newDestFolder = destItem as Folder;
            					if(newDestFolder == null)
            						return new ConflictResponse();
            				}
            			}
            			else
            			{
            				newDestFolder = CopyThisItem(destFolder,null,destName);
            			}
            			// copy children
            			MultistatusResponse mr = new MultistatusResponse();
            			if(deep)
            			{
            				foreach(IHierarchyItem child in Children)
            				{
            					HierarchyItem dbchild = child as HierarchyItem;
            					WebDAVResponse resp = dbchild.CopyTo(newDestFolder,child.Name,deep);
            					if(!resp.IsSuccess)
            						mr.AddResponses(new ItemResponse(dbchild.Path, resp));
            					else
            					{
            						MultistatusResponse mrchild = resp as MultistatusResponse;
            						if(mrchild != null)
            							mr.AddResponses(mrchild.Responses);
            					}
            				}
            			}
            
            			if(mr.Responses.Length > 0)
            				return mr;
            			else if(destItem == null)
            				return new CreatedResponse();
            			else
            				return new NoContentResponse();
            		}
            		...
            	}
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.MoveTo(ITHit.WebDAV.Server.IFolder,System.String)">
             <summary>
             Moves this item to the destination folder under a new name.
             </summary>
             <param name="folder">Destination folder</param>
             <param name="destName">Name of the destination item</param>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.CreatedResponse"/> - the move operation resulted in the creation of a new item.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.NoContentResponse"/> - the source item was successfully moved to a pre-existing destination item.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.ConflictResponse"/> - destination folder does not exist.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - the source or the destination item was locked and client did not provide lock token.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.MultistatusResponse"/> - errors has occured during processing of the subtree. Each <see cref="T:ITHit.WebDAV.Server.Response.ItemResponse"/> must contain info for every item that was successfully moved or failed to move.</description>
             </item>
             </list>
             </returns>
             <remarks>
             <papa>
             If the item is locked the server must not move any locks with the item. However, resources must be added to an existing lock at the destination.
             </papa>
             </remarks>
             <example>
             Example of <c>MoveTo</c> implementation for WebDAV Class 2 server:
             <code>
             public class Folder : HierarchyItem, IFolder, IFolderLock
             {
            		...
            		public override WebDAVResponse MoveTo(IFolder folder, string destName)
            		{
            			Folder destFolder = folder as Folder;
            			if(destFolder == null)
            				return new ConflictResponse();
                        
            			Folder parent = Parent as Folder;
            			if(parent == null)
            				return new ConflictResponse();
                        
            			if(!ClientHasToken || !destFolder.ClientHasToken || !parent.ClientHasToken)
            				return new LockedResponse();
            			
            			HierarchyItem destItem = destFolder.FindChild(destName);
            			Folder newDestFolder;
            
            			// copy this folder
            			if(destItem != null)
            			{
            				if(DelWhenReplace &amp;&amp; destItem is IResource)
            				{
            					WebDAVResponse delResp = destItem.Delete();
            					if(!delResp.IsSuccess)
            						return delResp;
            					newDestFolder = CopyThisItem(destFolder, null, destName);
            				}
            				else
            				{
            					newDestFolder = destItem as Folder;
            					if(newDestFolder == null)
            						return new ConflictResponse();
            				}
            			}
            			else
            			{
            				newDestFolder = CopyThisItem(destFolder, null, destName);
            			}
            			// move children
            			MultistatusResponse mr = new MultistatusResponse();
            			foreach(IHierarchyItem child in Children)
            			{
            				HierarchyItem dbchild = child as HierarchyItem;
            				WebDAVResponse resp = dbchild.MoveTo(newDestFolder, child.Name);
            				if(!resp.IsSuccess)
            					mr.AddResponses(new ItemResponse(dbchild.Path, resp));
            				else
            				{
            					MultistatusResponse mrchild = resp as MultistatusResponse;
            					if(mrchild != null)
            						mr.AddResponses(mrchild.Responses);
            				}
            			}
            
            			// delete this folder
            			if(mr.Responses.Length > 0)
            				return mr;
            			else if(destItem == null)
            			{
            				DeleteThisItem();
            				return new CreatedResponse();
            			}
            			else
            			{
            				DeleteThisItem();
            				return new NoContentResponse();
            			}
            		}
            		...
            	}
            	</code>
            	</example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.Delete">
             <summary>
             Deletes this item.
             </summary>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.NoContentResponse"/> - this item was successfully deleted.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - this item or its parent was locked and client did not provide lock token.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.MultistatusResponse"/> - errors has occured during processing of the subtree. Each <see cref="T:ITHit.WebDAV.Server.Response.ItemResponse"/> must contain info for every item that was successfully deleted or failed to delete.</description>
             </item>
             </list>
             </returns>
             <remarks>
             <para>
             <c>Delete</c> invocation must delete only folders and resource items. Lock-null items are deleted during <see cref="M:ITHit.WebDAV.Server.ILock.Unlock(System.String)"/> method call.
             </para>
             </remarks>
             <example>
             Example of <c>Delete</c> implementation for WebDAV Class 2 server:
             <code>
             public class Folder : HierarchyItem, IFolder, IFolderLock
             {
            		...
            		public override WebDAVResponse Delete()
            		{
            			Folder parent = Parent as Folder;
            			if(parent == null)
            				return new ConflictResponse();
            			if(!parent.ClientHasToken)
            				return new LockedResponse();
            
            			if(!ClientHasToken)
            				return new LockedResponse();
            
            			MultistatusResponse mr = new MultistatusResponse();
            
            			foreach(IHierarchyItem child in Children)
            			{
            				HierarchyItem dbchild = child as HierarchyItem;
            				WebDAVResponse resp = dbchild.Delete();
            				if(!resp.IsSuccess)
            					mr.AddResponses(new ItemResponse(dbchild.Path, resp));
            				else
            				{
            					MultistatusResponse mrchild = resp as MultistatusResponse;
            					if(mrchild != null)
            						mr.AddResponses(mrchild.Responses);
            				}
            			}
            
            			if(mr.Responses.Length > 0)
            				return mr;
            			else
            			{
            				DeleteThisItem();
            				return new NoContentResponse();
            			}
            		}
            		...
            	}
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.GetProperties(ITHit.WebDAV.Server.Property[]@)">
             <summary>
             Gets values of all properties or selected properties for this item.
             </summary>
             <param name="props">
             <list type="number">
             <item>
             <description>
             Array of properties which values are requested. 
             If a property does not exist for this hierarchy item then <see cref="F:ITHit.WebDAV.Server.Property.Value"/> field in the array should not be modified.
             </description>
             </item>
             <item>
             <description>
             <c>null</c> to get all properties. New array must be created and returned through this parameter.
             </description>
             </item>
             </list>
             </param>
             <returns>
            	<list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - All properties succesefully retrieved.</description>
             </item>
            	</list>
             </returns>
             <example>
             <code>
            		public WebDAVResponse GetProperties(ref Property[] props)
            		{
            			SqlConnection conn = new SqlConnection(connStr);
            			SqlCommand cmd;
            			SqlDataReader reader = null;
            			conn.Open();
                        
            			try
            			{
            				cmd = conn.CreateCommand();
            				cmd.CommandText = "SELECT Name, Namespace, PropVal"
            					+" FROM Properties"
            					+" WHERE ItemID = @ItemID";
                            
            				cmd.Parameters.Add("@ItemID", SqlDbType.Int).Value = ID;
                            
            				reader = cmd.ExecuteReader();
            				if(props == null) // get all properties
            				{
            					ArrayList l = new ArrayList();
            					while(reader.Read())
            					{
            						Property p = new Property();
            						p.Name = reader.GetString(reader.GetOrdinal("Name"));
            						p.Namespace = reader.GetString(reader.GetOrdinal("Namespace"));
            						p.Value = reader.GetString(reader.GetOrdinal("PropVal"));
            						l.Add(p);
            					}
            					props = (Property[])l.ToArray(typeof(Property));
            				}
            				else // get selected properties
            				{
            					Property p = new Property();
            					while(reader.Read())
            					{
            						p.Name = reader.GetString(reader.GetOrdinal("Name"));
            						p.Namespace = reader.GetString(reader.GetOrdinal("Namespace"));
            						for(int i=0; i&lt;props.Length; i++)
            							if(p.Name == props[i].Name &amp;&amp; p.Namespace == props[i].Namespace)
            							{
            								props[i].Value = reader.GetString(reader.GetOrdinal("PropVal"));
            								break;
            							}
            					}
            				}
            			}
            			finally
            			{
            				if(reader != null) reader.Close();
            				conn.Close();
            			}
            
            			return new OkResponse();
            		}
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.GetPropertyNames(ITHit.WebDAV.Server.Property[]@)">
            <summary>
            Gets names of all properties for this item.
            </summary>
            <param name="props">New array of properties must be created and returned through this parameter</param>
            <returns>
            <list type="bullet">
            <item>
            <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - All properties succesefully retrieved.</description>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Most WebDAV clients never request list of property names, so your implementation can just return <see cref="T:ITHit.WebDAV.Server.Response.NotAllowedResponse"/>.</para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(ITHit.WebDAV.Server.Property[],ITHit.WebDAV.Server.Property[])">
             <summary>
             Modifies and removes properties for this item.
             </summary>
             <param name="setProps">Array of properties to be set</param>
             <param name="delProps">
             Array of properties to be removed. <c>Value</c> field is ignored.
             Specifying the removal of a property that does not exist is not an error.
             </param>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - this item was locked and client did not provide lock token.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.MultipropResponse"/> - result of the operation for each property.</description>
             </item>
             </list>
             In <see cref="T:ITHit.WebDAV.Server.Response.MultipropResponse"/> each item could be:
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - the property was successfully updated or deleted.</description>
             </item>
             <item>
             <description>
             <see cref="T:ITHit.WebDAV.Server.Response.ConflictResponse"/> - the client has provided a value whose semantics are not appropriate for the property,
             this includes trying to set read-only properties.
             </description>
             </item>
             <item>
             <description>
             <see cref="T:ITHit.WebDAV.Server.Response.FailedDependencyResponse"/> - indicates this action would have succeeded if it were not for the conflict
             with updating/removing some other property.
             </description>
             </item>
             </list>
             </returns>
             <remarks>
             <para>
             In your <c>UpdateProperties</c> implementation you will create, modify and delete item properties. If any property failed to update than you should not modify any properties and rollback the entire operation. 
             To inform WebDAV client which properties failed to update you must return <see cref="T:ITHit.WebDAV.Server.Response.MultipropResponse"/> class instance. Each item of <see cref="T:ITHit.WebDAV.Server.Response.MultipropResponse"/> is the instance of <see cref="T:ITHit.WebDAV.Server.Response.PropResponse"/> class and provides information about individual property update operation.
             </para>
             </remarks>
             <example>
             <code>
            		public WebDAVResponse UpdateProperties(Property[] setProps, Property[] delProps)
            		{
            			if(!ClientHasToken) // required by class 2 server only
            				return new LockedResponse(); 
                        
            			MultipropResponse resp = new MultipropResponse();
            
            			SqlConnection conn = new SqlConnection(connStr);
            			SqlTransaction trans = null;
            			try
            			{
            				conn.Open();
            				trans = conn.BeginTransaction();
            
            				if(setProps != null)
            					foreach(Property p in setProps)
            					{
            						SetProperty(p, trans); // create or update property
            						resp.AddResponses(new PropResponse(p, new OkResponse()));
            					}
            
            				if(delProps != null)
            					foreach(Property p in delProps)
            					{
            						RemoveProperty(p.Name, p.Namespace, trans);
            						resp.AddResponses(new PropResponse(p, new OkResponse()));
            					}
            
            				UpdateModified(trans);
                            
            				trans.Commit();
            			}
            			catch
            			{
            				if(trans != null) trans.Rollback();
            				return new ServerErrorResponse();
            			}
            			finally
            			{
            				conn.Close();
            			}
            
            			return resp;
            		}
             </code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItem.Path">
            <summary>
            Unique item path in the repository relative to storage root.
            </summary>
            <remarks>
            <para>
            The URL returned by this property is relative to storage root. If your server root is located at http://example.webdavsystem.com:8080/myserver/ and the item URL is http://example.webdavsystem.com:8080/myserver/myfolder/myitem.doc this property implementation must return myfolder/myitem.doc. To calculate the entire item URL the engine will call <see cref="P:ITHit.WebDAV.Server.Request.ApplicationPath"/> property and attach it to url returned by <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Path"/> property.
            </para>
            <para>Examples:
            <list type="bullet">
            <item><description>Resource: myfolder/mydoc.docx</description></item>
            <item><description>Folder: myfolder/folder/</description></item>
            <item><description>Lock-null item: myfolder/mydoc.docx</description></item>
            <item><description>History item: myfolder/mydoc.docx?history</description></item>
            <item><description>Version: myfolder/mydoc.docx?version=5</description></item>
            </list>
            </para>
            </remarks>
            <value><c>String</c> representing retative item path in the repository.</value>
        </member>
        <member name="T:ITHit.WebDAV.Server.ILock">
            <summary>
            Defines the properties and methods that WebDAV Class 2 compliant server hierarchy items must implement.
            </summary>
            <remarks>
            Classes that implement this interface represent WebDAV class 2 server hierarchy items.
            To create DAV Class 2 compliant server you must implement this interface on your resource items
            and <see cref="T:ITHit.WebDAV.Server.IFolderLock"/> on your folder items. <c>ILock</c> provides methods and properties common to all WebDAV
            folders, resources anl lock-null items.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.ILock.ActiveLocks">
             <summary>
             Gets the array of all locks for this item.
             </summary>
             <remarks>
             <para>
             This property must return all locks for the item including deep locks on any of the parent folders.
             All fields of each <see cref="T:ITHit.WebDAV.Server.LockInfo"/> structure in the array must be set.
             </para>
             </remarks>
             <example>
             <code>
            		public LockInfo[] ActiveLocks
            		{
            			get
            			{
            				int itemID = ID;
            				ArrayList l = new ArrayList();
                            
            				SqlConnection conn = new SqlConnection(connStr);
            				SqlCommand cmd;
            				conn.Open();
            				try
            				{
            					cmd = conn.CreateCommand();
            					cmd.CommandText = "SELECT Parent FROM Repository WHERE ID = @ID";
            					cmd.Parameters.Add("@ID", SqlDbType.Int);
            					cmd.Prepare();
            
            					l.AddRange(GetLocks(ID, false)); // get all locks
            					while(true)
            					{
            						cmd.Parameters["@ID"].Value = itemID;
            						itemID = (int)cmd.ExecuteScalar();
            						if(itemID &lt;= 0) break;
            						l.AddRange(GetLocks(itemID, true));  // get only deep locks
            					}
            				}
            				finally
            				{
            					conn.Close();
            				}
            
            				return (LockInfo[])l.ToArray(typeof(LockInfo));
            			}
            		}
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ILock.Lock(ITHit.WebDAV.Server.LockInfo@)">
             <summary>
             Locks this item.
             </summary>
             <param name="lockInfo">Describes a lock on this item</param>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - the lock request succeeded.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - the item is locked, so the method has been rejected.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.MultistatusResponse"/>- errors has occured during processing of the subtree.</description>
             </item>
             </list>
             </returns>
             <remarks>
             WebDAV engine passes <see cref="T:ITHit.WebDAV.Server.LockInfo"/> structure to this method by reference.
             All fields of the structure are provided by WebDAV client except <see cref="F:ITHit.WebDAV.Server.LockInfo.Token"/> field.
             In your <c>Lock</c> implementation you must create lock token and set <see cref="F:ITHit.WebDAV.Server.LockInfo.Token"/> member. You must also associate generated token with the hierarchy item in the repository during this call. The token is sent to the WebDAV client.
             </remarks>
             <example>
             <code>
            		public WebDAVResponse Lock(ref LockInfo lockInfo)
            		{
            			if(ItemHasLock(lockInfo.Shared))
            				return new LockedResponse();
            
            			if(lockInfo.Deep)
            			{
            				MultistatusResponse mr = FindLocksDown(this, lockInfo.Shared);
            				if(mr.Responses.Length > 0)
            					return mr;
            			}
            
            			SqlConnection conn = new SqlConnection(connStr);
            			SqlCommand cmd;
            			conn.Open();
            			try
            			{
            				cmd = conn.CreateCommand();
            				cmd.CommandText = "INSERT INTO Lock (ItemID,Token,Shared,Deep,Expires,Owner)"
            					+" VALUES(@ItemID, @Token, @Shared, @Deep, @Expires, @Owner)";
                        
            				lockInfo.Token = Guid.NewGuid().ToString();
                            
            				cmd.Parameters.Add("@ItemID", SqlDbType.Int).Value = ID;
            				cmd.Parameters.Add("@Token", SqlDbType.Char).Value = lockInfo.Token;
            				cmd.Parameters.Add("@Shared", SqlDbType.Bit).Value = lockInfo.Shared;
            				cmd.Parameters.Add("@Deep", SqlDbType.Bit).Value = lockInfo.Deep;
            				cmd.Parameters.Add("@Expires", SqlDbType.DateTime);
            				if(lockInfo.Timeout >= 0)
            				{
            					cmd.Parameters["@Expires"].Value = DateTime.Now.AddSeconds(lockInfo.Timeout);
            				}
            				else
            				{
            					cmd.Parameters["@Expires"].Value = SqlDateTime.Null;
            				}
            				cmd.Parameters.Add("@Owner", SqlDbType.NVarChar).Value = lockInfo.Owner;
            
            				cmd.ExecuteNonQuery();
            			}
            			finally
            			{
            				conn.Close();
            			}
            
            			return new OkResponse();
            		}
            
            		protected bool ItemHasLock(bool skipShared)
            		{
            			LockInfo[] locks = ActiveLocks;
            			if(locks.Length == 0)
            				return false;
            			return !(skipShared &amp;&amp; locks[0].Shared);
            		}
            
            		protected static MultistatusResponse FindLocksDown(IHierarchyItem root, bool skipShared)
            		{
            			MultistatusResponse mr = new MultistatusResponse();
            			IFolder folder = root as IFolder;
            			if(folder != null)
            				foreach(IHierarchyItem child in folder.Children)
            				{
            					HierarchyItem dbchild = child as HierarchyItem;
            					if(dbchild.ItemHasLock(skipShared))
            						mr.AddResponses(new ItemResponse(dbchild.Path, new LockedResponse()));
            					MultistatusResponse mrchild = FindLocksDown(child, skipShared);
            					mr.AddResponses(mrchild.Responses);
            				}
            			return mr;
            		}		
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ILock.RefreshLock(ITHit.WebDAV.Server.LockInfo@)">
             <summary>
             Updates lock timeout information on this item.
             </summary>
             <param name="lockInfo">Describes a lock on this item</param>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - the lock timeout information was successfully updated.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.PreconditionFailedResponse"/> - the included lock token was not enforceable on this item.</description>
             </item>
             </list>
             </returns>
             <remarks>
             WebDAV engine passes <see cref="T:ITHit.WebDAV.Server.LockInfo"/> structure to this method by reference.
             <see cref="F:ITHit.WebDAV.Server.LockInfo.Token"/> and <see cref="F:ITHit.WebDAV.Server.LockInfo.Timeout"/> fields are provided by WebDAV client.
             In your <see cref="M:ITHit.WebDAV.Server.ILock.RefreshLock(ITHit.WebDAV.Server.LockInfo@)"/> implementation you must set
             <see cref="F:ITHit.WebDAV.Server.LockInfo.Shared"/>, <see cref="F:ITHit.WebDAV.Server.LockInfo.Deep"/> and <see cref="F:ITHit.WebDAV.Server.LockInfo.Owner"/> fields.
             </remarks>
             <example>
             <code>
            		public WebDAVResponse RefreshLock(ref LockInfo lockInfo)
            		{
            			LockInfo[] locks = ActiveLocks;
            
            			int lockIndex;
            			for(int lockIndex = 0; lockIndex &lt; locks.Length; lockIndex++)
            				if(lockInfo.Token == locks[lockIndex].Token) break;
            
            			if(lockIndex == locks.Length)
            				return new PreconditionFailedResponse();
            
            			SqlConnection conn = new SqlConnection(connStr);
            			SqlCommand cmd;
            			conn.Open();
            
            			try
            			{
            				cmd = conn.CreateCommand();
            				cmd.CommandText = "UPDATE Lock SET Expires = @Expires WHERE Token LIKE @Token";
                            
            				cmd.Parameters.Add("@Expires", SqlDbType.DateTime);
            				if(lockInfo.Timeout >= 0)
            				{
            					cmd.Parameters["@Expires"].Value = DateTime.Now.AddSeconds(lockInfo.Timeout);
            				}
            				else
            				{
            					cmd.Parameters["@Expires"].Value = SqlBoolean.Null;
            				}
            				cmd.Parameters.Add("@Token", SqlDbType.Char).Value = lockInfo.Token;
            
            				cmd.ExecuteNonQuery();
            			}
            			finally
            			{
            				conn.Close();
            			}
            
            			// return info about lock to WebDAV engine
            			lockInfo.Shared = locks[lockIndex].Shared;
            			lockInfo.Deep = locks[lockIndex].Deep;
            			lockInfo.Owner = locks[lockIndex].Owner;
            
            			return new OkResponse();
            		}
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ILock.Unlock(System.String)">
             <summary>
             Removes lock with the specified token from this item or deletes lock-null item.
             </summary>
             <param name="lockToken">Lock with this token should be removed from the item</param>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.NoContentResponse"/> - the lock identified by the specified lock token was successfully removed from the item.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.PreconditionFailedResponse"/> - the included lock token was not enforceable on this item.</description>
             </item>
             </list>
             </returns>
             <remarks>
             <para>
             If this lock included more than one hierarchy item, the lock is removed from all items included in the lock.
             If the lock-null item is unlocked using this method then it must be removed from the WebDAV hierarchy.
             </para>
             </remarks>
             <example>
             <code>
            public WebDAVResponse Unlock(string lockToken)
            {
            	LockInfo[] locks = ActiveLocks;
            	int i;
                
            	for(i=0;i&lt;locks.Length;i++)
            		if(locks[i].Token == lockToken) break;
                
            	if(i == locks.Length)
            		return new PreconditionFailedResponse();
            
            	if(this is ILockNull)
            	{ // delete lock-null item
            		DeleteThisItem();
            	}
            	else
            	{ // remove lock from existing item
            		SqlConnection conn = new SqlConnection(connStr);
            		SqlCommand cmd;
            		conn.Open();
            		try
            		{
            			cmd = conn.CreateCommand();
            			cmd.CommandText = "DELETE FROM Lock WHERE Token LIKE @Token";
            			cmd.Parameters.Add("@Token", SqlDbType.NVarChar).Value = lockToken;
            			cmd.ExecuteNonQuery();
            		}
            		finally
            		{
            			conn.Close();
            		}
            	}
            
            	return new NoContentResponse();
            }
             </code>
             </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.ILockNull">
             <summary>
             Represents a lock-null item in a repository of class 2 WebDAV server.
             </summary>
             <remarks>
             <para>
             Classes that implement this interface represent WebDAV class 2 server lock-null items. In addition to methods and properties provided by <see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/> and <see cref="T:ITHit.WebDAV.Server.ILock"/> this interface also provides methods for converting a lock-null item to a folder or resource.
             </para>
             <para>
             The lock-null items are created before folders and resources creation. WebDAV client creates lock-null item with a specified name and than converts it to a resource or folder. However client can also issue folder and resource creation requests without creating lock-null item.
             </para>
             <para>
             Lock-null items are crated during a call to <see cref="M:ITHit.WebDAV.Server.IFolderLock.CreateLockNull(System.String,ITHit.WebDAV.Server.LockInfo@)"/> method and converted to a resource or folder during a call to <see cref="M:ITHit.WebDAV.Server.ILockNull.ConvertToResource"/> or <see cref="M:ITHit.WebDAV.Server.ILockNull.ConvertToFolder"/> methods.
             </para>
             <para>
             A lock-null item can not be moved, copied or deleted. It must return <see cref="T:ITHit.WebDAV.Server.Response.NotAllowedResponse"/> from <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.CopyTo(ITHit.WebDAV.Server.IFolder,System.String,System.Boolean)"/>, <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.MoveTo(ITHit.WebDAV.Server.IFolder,System.String)"/>, <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.Delete"/> and <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(ITHit.WebDAV.Server.Property[],ITHit.WebDAV.Server.Property[])"/> implementations. If the item was not converted to a resource or folder and WebDAV client issues unlock request with appropriate lock token the item must be deleted.
             </para>
             <para>
             A lock-null item must appear among <see cref="P:ITHit.WebDAV.Server.IFolder.Children"/> items of the folder where it was created.
             </para>
             </remarks>
             <example>
             <code>
            	public class LockNull : HierarchyItem, ILockNull
            	{
            		public LockNull(int id, string name, string path, DateTime created, DateTime modified)
            			:base(id, name, path, created, modified)
            		{
            		}
            
            		public WebDAVResponse ConvertToResource()
            		{
            			if(!ClientHasToken)
            				return new LockedResponse();
            
            			SqlConnection conn = new SqlConnection(connStr);
            			SqlTransaction trans = null;
            			conn.Open();
            			try
            			{
            				trans = conn.BeginTransaction();
            				CreateItemFromLockNull(trans, ID, ItemType.Resource);
            				trans.Commit();
            			}
            			catch(Exception ex)
            			{
            				if(trans != null) trans.Rollback();
            				throw;
            			}
            			finally
            			{
            				conn.Close();
            			}
            			return new CreatedResponse();
            		}
            
            		public WebDAVResponse ConvertToFolder()
            		{
            			if(!ClientHasToken)
            				return new LockedResponse();
            
            			SqlConnection conn = new SqlConnection(connStr);
            			SqlTransaction trans = null;
            			conn.Open();
            			try
            			{
            				trans = conn.BeginTransaction();
            				CreateItemFromLockNull(trans, ID, ItemType.Folder);
            				trans.Commit();
            			}
            			catch(Exception ex)
            			{
            				if(trans != null) trans.Rollback();
            				throw;
            			}
            			finally
            			{
            				conn.Close();
            			}
            
            			return new CreatedResponse();
            		}
            
            		public override WebDAVResponse CopyTo(IFolder folder, string destName, bool deep)
            		{
            			return new NotAllowedResponse();
            		}
            
            		public override WebDAVResponse MoveTo(IFolder folder, string destName)
            		{
            			return new NotAllowedResponse();
            		}
            
            		public override WebDAVResponse Delete()
            		{
            			return new NotAllowedResponse();
            		}
            
            		public override WebDAVResponse UpdateProperties(Property[] setProps, Property[] delProps)
            		{
            			return new NotAllowedResponse();
            		}
            
            		private void CreateItemFromLockNull(SqlTransaction trans, int lockNullID, ItemType itemType)
            		{ // set item type
            			SqlCommand cmd = trans.Connection.CreateCommand();
            			cmd.Transaction = trans;
            			cmd.CommandText = "UPDATE Repository SET ItemType = @ItemType WHERE ID = @ID";
            			cmd.Parameters.Add("@ItemType", SqlDbType.Int).Value = itemType;
            			cmd.Parameters.Add("@ID", SqlDbType.Int).Value = lockNullID;
            			cmd.ExecuteNonQuery();
                            
            			UpdateModified(trans);
            		}
            	}
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ILockNull.ConvertToResource">
             <summary>
             Converts lock-null item to resource.
             </summary>
             <returns>
             <list type="bullet">
             <item><description><see cref="T:ITHit.WebDAV.Server.Response.CreatedResponse"/> - A null-lock item was successfully converted to a resource.</description></item>
             <item><description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - The folder was locked. Client did not provide the lock token.</description></item>
             </list>
             </returns>
             <remarks>Engine calls this method when lock-null item must be converted to a resource. After calling this method Engine calls <see cref="M:ITHit.WebDAV.Server.IResource.SaveFromStream(System.IO.Stream,System.String)">IResource.SaveFromStream</see> or <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.SaveFromStream(System.Int64,System.Int64,System.IO.Stream,System.String)">IResumableUpload.SaveFromStream</see>.
             </remarks>
             <example>
             <code>
            	public WebDAVResponse ConvertToResource()
            	{
            		FileInfo file = (FileInfo)base.fileSystemInfo;
            
            		file.Attributes &amp;= ~FileAttributes.Temporary; // remove lock-null marker
            
            		return new CreatedResponse();
            	}
            	</code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ILockNull.ConvertToFolder">
             <summary>
             Converts lock-null item to folder.
             </summary>
             <returns>
             <list type="bullet">
             <item><description><see cref="T:ITHit.WebDAV.Server.Response.CreatedResponse"/> - A null-lock item was successfully converted to a folder.</description></item>
             <item><description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - The folder was locked. Client did not provide the lock token.</description></item>
             </list>
             </returns>
             <remarks>Engine calls this method when lock-null item must be converted to a folder.
             </remarks>
             <example>
             <code>
            	public WebDAVResponse ConvertToFolder()
            	{
            		FileInfo file = (FileInfo)base.fileSystemInfo;
            		string path = file.FullName;
            		file.Delete();
            		Directory.CreateDirectory(path);
            
            		return new CreatedResponse();
            	}
            	</code>
             </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.IMethodHandler">
            <summary>
            Represents HTTP method handler.
            </summary>
            <remarks>
            <para>
            The IT Hit WebDAV Server Engine allows creating custom HTTP handlers and replacing original engine handlers. 
            To add or replace handler call <see cref="M:ITHit.WebDAV.Server.Engine.RegisterMethodHandler(System.String,ITHit.WebDAV.Server.IMethodHandler)" /> method passing HTTP method name and object instance 
            implementing <see cref="T:ITHit.WebDAV.Server.IMethodHandler" /> interface prior to calling <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)" />. The original handler, if any, 
            is returned from <see cref="M:ITHit.WebDAV.Server.Engine.RegisterMethodHandler(System.String,ITHit.WebDAV.Server.IMethodHandler)" /> method. 
            </para>
            <para>
            The <see cref="M:ITHit.WebDAV.Server.IMethodHandler.ProcessRequest(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse,ITHit.WebDAV.Server.IHierarchyItem)" /> method of this interface is called by the engine during <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)" /> call. 
            The hierarchy item returned from <see cref="M:ITHit.WebDAV.Server.Engine.GetHierarchyItem(System.String)" /> is passed to ProcessRequest method as a parameter.
            </para>
            </remarks>
            <example>
			The WebDAV protocol does not regulate GET request to a WebDAV collection (folder). The following sample demonstrates custom handler for GET request submitted to folder item. The custom handler returns HTML page for folder while calling the original handler for any other items.
			<code>
				<![CDATA[
WDEngine engine = new WDEngine();
// set custom handler to process GET requests to folders
MyCustomGetHandler handler = new MyCustomGetHandler();
handler.OriginalHandler = engine.RegisterMethodHandler("GET", handler);
engine.Run(request, response);

class MyCustomGetHandler : IMethodHandler
{
    private IMethodHandler originalHandler;

    public IMethodHandler OriginalHandler
    {
        set { originalHandler = value; }
    }

    public void ProcessRequest(Request request, IResponse response, IHierarchyItem item)
    {
        if(item is IFolder)
            HttpContext.Current.Response.TransmitFile(HttpContext.Current.Request.PhysicalApplicationPath + "MyCustomHandlerPage.html");
        else
            originalHandler.ProcessRequest(request, response, item);
    }
}
				]]>
			</code>
		</example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IMethodHandler.ProcessRequest(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse,ITHit.WebDAV.Server.IHierarchyItem)">
            <summary>
            Enables processing of HTTP Web requests by a custom handler.
            </summary>
            <param name="request">Instance of your request class derived from <see cref="T:ITHit.WebDAV.Server.Request"/> class</param>
            <param name="response">Your <see cref="T:ITHit.WebDAV.Server.IResponse"/> interface implementation</param>
            <param name="item">Hierarchy item returned from <see cref="M:ITHit.WebDAV.Server.Engine.GetHierarchyItem(System.String)"/> or <b>null</b></param>
            <remarks>The <see cref="M:ITHit.WebDAV.Server.IMethodHandler.ProcessRequest(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse,ITHit.WebDAV.Server.IHierarchyItem)"/> method is called by the engine during <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)"/> call. 
            The hierarchy item returned from <see cref="M:ITHit.WebDAV.Server.Engine.GetHierarchyItem(System.String)"/> is passed to this method. 
            If <see cref="M:ITHit.WebDAV.Server.Engine.GetHierarchyItem(System.String)"/> returns null the null is passed.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.IResource">
             <summary>
             Represents a resource in the WebDAV repository.
             </summary>
             <remarks>
             Defines the properties and methods that WebDAV server resource objects must implement.
             In addition to methods and properties provided by <see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/>
             this interface also provides methods for reading and writing resource content.
             <see cref="P:ITHit.WebDAV.Server.IResource.ContentType"/> property must return the MIME type of the resource.
             </remarks>
             <example>
             <code>
            	public class Resource : HierarchyItem, IResource
            	{
            		public Resource(FileInfo file)
            			: base(file)
            		{
            		}
            
            		public string ContentType
            		{
            			get
            			{
            				return MimeType.GetMimeType(this.fileSystemInfo.Extension) ?? "application/octet-stream";
            			}
            		}
            
            		public long ContentLength
            		{
            			get
            			{
            				FileInfo file = (FileInfo)base.fileSystemInfo;
            				return file.Length;
            			}
            		}
            
            		public WebDAVResponse WriteToStream(Stream output, long startIndex, long count)
            		{
            			FileInfo file = (FileInfo)base.fileSystemInfo;
            			byte[] buffer = new byte[bufSize];
            			int bytesRead;
            			FileStream fileStream = null;
            			try
            			{
            				fileStream = file.Open(FileMode.Open, FileAccess.Read, FileShare.Read);
            				fileStream.Seek(startIndex, SeekOrigin.Begin);
            				while ((bytesRead = fileStream.Read(buffer, 0, (int)(count > bufSize ? bufSize : count))) > 0)
            				{
            					try
            					{
            						output.Write(buffer, 0, bytesRead);
            					}
            					catch (System.Net.HttpListenerException ex)
            					{ // client closed connection
            						// 1. ErrorCode=1229. An operation was attempted on a nonexistent network connection.
            						// 2. ErrorCode=64. The specified network name is no longer available.
            						return new OkResponse();
            					}
            					count -= bytesRead;
            				}
            			}
            			finally
            			{
            				if (fileStream != null) 
            					fileStream.Close();
            			}
            
            			return new OkResponse();
            		}
            
            		public WebDAVResponse SaveFromStream(Stream content, string contentType)
            		{
            			FileInfo file = (FileInfo)base.fileSystemInfo;
            
            			byte[] buffer = new byte[bufSize];
            			int bytesRead;
            			FileStream fileStream = null;
            			try
            			{
            				fileStream = file.Open(FileMode.Truncate, FileAccess.Write);
            				while ((bytesRead = content.Read(buffer, 0, bufSize)) > 0)
            					fileStream.Write(buffer, 0, bytesRead);
            			}
            			finally
            			{
            				if (fileStream != null)
            					fileStream.Close();
            			}
            
            			return new OkResponse();
            		}
            
            		public override WebDAVResponse Delete()
            		{
            			fileSystemInfo.Delete();
            			return new NoContentResponse();
            		}
            	</code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IResource.ContentType">
             <summary>
             Gets the media type of the resource.
             </summary>
             <remarks>
             <para>
             The mime-type provided by this property is returned in a Content-Type header with GET request.
             </para>
             <para>
             When deciding which action to perform when downloading a file some WebDAV clients and browsers (such as Internet Explorer) 
             rely on file extension, while others (such as Firefox) rely on Content-Type header returned by server. 
             For identical behavior in all browsers and WebDAV clients your server must return a correct mime-type with a requested file.
             </para>
             </remarks>
             <example>
             <code>
            	public string ContentType
            	{
            		get
            		{
            			string contentType = "";
            
            			SqlConnection conn = new SqlConnection(connStr);
            			SqlCommand cmd;
            			SqlDataReader reader = null;
            			conn.Open();
                        
            			try
            			{
            				cmd = conn.CreateCommand();
            				cmd.CommandText = "SELECT ContentType FROM Repository WHERE ID = @ID";
            				cmd.Parameters.Add("@ID", SqlDbType.Int).Value = ID;
            				reader = cmd.ExecuteReader();
            				reader.Read();
            				if(!reader.IsDBNull(reader.GetOrdinal("ContentType")))
            					contentType = reader.GetString(reader.GetOrdinal("ContentType"));
            			}
            			finally
            			{
            				if(reader != null) reader.Close();
            				conn.Close();
            			}
            
            			if (string.IsNullOrEmpty(contentType))
                         contentType = 
                             MimeType.GetMimeType(System.IO.Path.GetExtension(this.fName))
                             ?? "application/octet-stream";
            			return contentType;
            		}
            	}
             </code>
             </example>
             <value>The MIME type of the resource.</value>
        </member>
        <member name="P:ITHit.WebDAV.Server.IResource.ContentLength">
            <summary>
            Gets the size of the resource content in bytes.
            </summary>
            <value>Length of the resource content in bytes.</value>
        </member>
        <member name="M:ITHit.WebDAV.Server.IResource.WriteToStream(System.IO.Stream,System.Int64,System.Int64)">
             <summary>
             Writes the content of the resource to the specified stream.
             </summary>
             <param name="output">Output stream</param>
             <param name="startIndex">The zero-bazed byte offset in resource content at which to begin copying bytes to the output stream</param>
             <param name="count">The number of bytes to be written to the output stream</param>
             <returns>
            	<list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - Operation succeeded.</description>
             </item>
            	</list>
             </returns>
             <remarks>
             <para>
             By default ASP.NET buffers content on server side before sending output. You must turn off buffering to eliminate keeping entire file content in memory before sending:
             <code>
             HttpContext.Current.Response.BufferOutput = false;
             </code>
             </para>
             <para>
             Client application can request only a part of a resource specifying <b>Range</b> header. Download managers may use this header to download single file using several threads at a time.
             </para>
             </remarks>
             <example>
             <code>
            	public WebDAVResponse WriteToStream(Stream output, long byteStart, long count)
            	{
            		System.Web.HttpContext.Current.Server.ScriptTimeout = 1200;
            
            		SqlConnection conn = new SqlConnection(connStr);
            		SqlCommand cmd;
            		SqlDataReader reader = null;
            		conn.Open();
            
            		try
            		{
            			cmd = conn.CreateCommand();
            			cmd.CommandText = "SELECT Content FROM Repository WHERE ID = @ID";
            			cmd.Parameters.Add("@ID", SqlDbType.Int).Value = ID;
                    
            			reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess);
            			reader.Read();
                        
            			long bufSize = 1048576; // 1Mb
            			byte[] buf = new byte[bufSize];
            			long retval;
            			long startIndex = byteStart;
                        
            			while ((retval = reader.GetBytes(reader.GetOrdinal("Content"), 
            				startIndex, buf, 0, (int)(count>bufSize ? bufSize : count) )) > 0)
            			{
            				try
            				{
            					output.Write(buf, 0, (int)retval);
            				}
            				catch (System.Web.HttpException)
            				{ // The remote host closed the connection
            					return new OkResponse();
            				}
            				startIndex += retval;
            				count-=retval;
            			}
            		}
            		finally
            		{
            			if(reader != null) reader.Close();
            			conn.Close();
            		}
            
            		return new OkResponse();
            	}
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IResource.SaveFromStream(System.IO.Stream,System.String)">
             <summary>
             Saves the content of the resource from the specified stream to the WebDAV repository.
             </summary>
             <param name="content">Stream to read the content of the resource from</param>
             <param name="contentType">Indicates the media type of the resource</param>
             <returns>
             <list type="bullet">
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.OkResponse"/> - the resource content was successfully stored.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.NoContentResponse"/> - the size of the resource content was truncated to zero.</description>
             </item>
             <item>
             <description><see cref="T:ITHit.WebDAV.Server.Response.LockedResponse"/> - the resource was locked and client did not provide lock token.</description>
             </item>
             </list>
             </returns>
             <remarks>
             <para>IIS and ASP.NET does not support files upload larger than 2Gb. If you need to upload files larger than 2Gb you must develop HttpListener-based WebDAV server or implement resumable upload interfaces.</para>
             <para>
             If you are creating HttpHandler-based WebDAV server you must specify the file 
             maximum upload size in web.config of your web application. By default maximum 
             upload size is set to 4096 KB (4 MB) by ASP.NET. This limit is used to 
             prevent denial of service attacks caused by users posting large files to the 
             server. To increase the upload limit add &lt;httpRuntime&gt; section to your web application web.config file and specify the limit in kilobytes: 
             </para>
             <code>
            	&lt;configuration&gt;
            		&lt;system.web&gt;
            		...
            			&lt;httpRuntime maxRequestLength="2097151" /&gt; //2Gb
            		...
            		&lt;/system.web&gt;
            	&lt;/configuration&gt;
             </code>
             <para>
             When client uploads file to IIS, ASP.NET first creates the file in a the temporary upload directory. Only when the entire file is uploaded to server you can read its content from stream. By default ASP.NET uploads files to <b>%FrameworkInstallLocation%\Temporary ASP.NET Files</b> folder. You must make sure you have enough disk space to keep temporary files uploaded to your server. To change this folder location add the following section to your web.config file:
             <code>
             &lt;configuration&gt;
            		&lt;system.web&gt;
            		...
            			&lt;compilation tempDirectory="temporary files directory" /&gt;
            		...
            		&lt;/system.web&gt;
            	&lt;/configuration&gt;
             </code>
             To avoid temporary file creation and pass content directly to engine set the <see cref="T:ITHit.WebDAV.Server.ResumableUpload.ResumableUploadModule"/> module in your web.config file.
             Unlike IIS/ASP.NET, HttpListener-based server does not create any temporary files when handling uploads.
             </para>
             </remarks>
             <example>
             <code>
            public WebDAVResponse SaveFromStream(Stream stream, string contentType)
            {
            	if (!ClientHasToken)
            		return new LockedResponse();
            
            	WebDAVResponse resp;
            
            	SqlConnection conn = new SqlConnection(connStr);
            	SqlCommand cmd;
            	SqlTransaction trans = null;
            	conn.Open();
                
            	try
            	{
            		trans = conn.BeginTransaction();
            		cmd = conn.CreateCommand();
            		cmd.Transaction = trans;
                    
            		if (stream.Length &gt; 0)
            		{
            			int bufSize = 4096;
                        
            			cmd.CommandText = "UPDATE Repository SET"
            				+ " Modified = GETUTCDATE(),"
            				+ " Content = NULL,"
            				+ " ContentType = @ContentType"
            				+ " WHERE ID = @ID;"
            				+ "SELECT @Pointer = TEXTPTR(Content) FROM Repository WHERE ID = @ID";
            
            			cmd.Parameters.Add("@ContentType", SqlDbType.NVarChar).Value = contentType;
            			cmd.Parameters.Add("@ID", SqlDbType.Int).Value = ID;
                        
            			SqlParameter ptrParm = cmd.Parameters.Add("@Pointer", SqlDbType.Binary, 16);
            			ptrParm.Direction = ParameterDirection.Output;
                        
            			cmd.ExecuteNonQuery();
            
            			cmd.CommandText = "UPDATETEXT Repository.Content @Pointer @Offset NULL @Bytes";
            
            			cmd.Parameters.Clear();
            			cmd.Parameters.Add("@Pointer", SqlDbType.Binary, 16).Value = ptrParm.Value;
            			SqlParameter offsetParm = cmd.Parameters.Add("@Offset", SqlDbType.Int);
            			SqlParameter bytesParm = cmd.Parameters.Add("@Bytes", SqlDbType.Image, bufSize);
            
            			BinaryReader br = new BinaryReader(stream);
                        
            			byte[] buf = br.ReadBytes(bufSize);
            			int offset_ctr = 0;
                        
            			while (buf.Length &gt; 0)
            			{
            				bytesParm.Value = buf;
            				offsetParm.Value = offset_ctr;
            				cmd.ExecuteNonQuery();
            				offset_ctr += buf.Length;
            				buf = br.ReadBytes(bufSize);
            			}
            
            			br.Close();
            
            			resp = new OkResponse();
            		}
            		else
            		{
            			cmd.CommandText = "UPDATE Repository SET"
            				+ " Modified = GETUTCDATE(),"
            				+ " Content = NULL,"
            				+ " ContentType = @ContentType"
            				+ " WHERE ID = @ID";
                        
            			cmd.Parameters.Add("@ContentType", SqlDbType.NVarChar).Value = contentType;
            			cmd.Parameters.Add("@ID", SqlDbType.Int).Value = ID;
            
            			cmd.ExecuteNonQuery();
                        
            			resp = new NoContentResponse();
            		}
            
            		trans.Commit();
            	}
            	catch
            	{
            		if(trans != null) trans.Rollback();
            		resp = new ServerErrorResponse();
            	}
            	finally
            	{
            		conn.Close();
            	}
            
            	return resp;
            }
             </code>
             </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.IResponse">
            <summary>
            Represents HTTP response.
            </summary>
            <remarks>
            <para>
            Usually you do not have to implement this interfaces if you host your server in ASP.NET/IIS or in HttpListener as Engine provides overloaded <c>Run</c> methods optimized for ASP.NET/IIS and for HttpListener. You can implement this interface if you host your server  in any other environment and pass it to <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)"/> method.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.IResponse.StatusCode">
            <summary>
            Gets or sets the HTTP status code of the output returned to the client.
            </summary>
            <value>
            An Integer representing the status of the HTTP output returned to the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.IResponse.StatusDescription">
            <summary>
            Sets the HTTP status string of the output returned to the client.
            </summary>
            <value>
            A string describing the status of the HTTP output returned to the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.IResponse.ContentType">
            <summary>
            Sets the HTTP MIME type of the output stream.
            </summary>
            <value>
            The HTTP MIME type of the output stream.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.IResponse.ContentEncoding">
            <summary>
            Sets the HTTP character set of the output stream.
            </summary>
            <value>
            A <c>Encoding</c> object containing information about the character set of the current response.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.IResponse.ContentLength">
            <summary>
            Sets the content length of the output stream.
            </summary>
            <value>
            The value of the response's Content-Length header.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.IResponse.OutputStream">
            <summary>
            Enables binary output to the outgoing HTTP content body.
            </summary>
            <value>
            An IO <see cref="T:System.IO.Stream"/> representing the raw contents of the outgoing HTTP content body.
            </value>
        </member>
        <member name="M:ITHit.WebDAV.Server.IResponse.AddHeader(System.String,System.String)">
            <summary>
            Adds the specified header and value to the HTTP headers for this response.
            </summary>
            <param name="name">
            The name of the HTTP header to set.
            </param>
            <param name="value">
            The value for the name header.
            </param>
        </member>
        <member name="M:ITHit.WebDAV.Server.IResponse.Clear">
            <summary>
            Clears all content output from the buffer stream.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.License.LicenseChecker">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.CheckLicense(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.AddBigIntegers(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.DivideBigIntegers(System.Int64[],System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.MultiplyBigIntegers(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.SubtractBigIntegers(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.UnaryNegationBigInteger(System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.LessThanOrEqualBigInteger(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.ModulusBigInteger(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.CryptographyTest">
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.LicenseValidator">
            <summary>
            Summary description for LicenseValidator.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.LockInfo">
            <summary>
            Serves for exchanging locking information with WebDAV engine.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.LockInfo.Token">
            <summary>
            The lock token associated with a lock.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.LockInfo.Shared">
            <summary>
            Indicates whether a lock is shared or exclusive.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.LockInfo.Deep">
            <summary>
            Indicates whether a lock is enforceable on the subtree.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.LockInfo.Timeout">
            <summary>
            Lock expiration time.
            </summary>
            <remarks>
            The expiration timeout in seconds associated with a lock. -1 means infinity (no expiration).
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.LockInfo.Owner">
            <summary>
            Provides information about the principal taking out a lock.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.MimeType">
             <summary>
             Provides functionality for getting mime type by file extension.
             </summary>
             <remarks>
             <para>
             The <see cref="M:ITHit.WebDAV.Server.MimeType.GetMimeType(System.String)"/> static method of this class returns mime type by provided file extension. 
             The class is usually utilized in <see cref="P:ITHit.WebDAV.Server.IResource.ContentType"/> implementation. The mime-type is returned in a Content-Type header with GET request.
             The set of values can be extended with using <see cref="M:ITHit.WebDAV.Server.MimeType.ExtendTypesTable(System.String,System.String)"/> method.
             </para>
             <para>
             When deciding which action to perform when downloading a file some WebDAV clients and browsers (such as Internet Explorer) rely on file extension, 
             while others (such as Firefox) rely on Content-Type header returned by server. 
             For identical behavior in all browsers and WebDAV clients your server must return a correct mime-type with a requested file.
             </para>
             </remarks>
             <example>
             <code>
            	public string ContentType
            	{
            		get
            		{
            			string contentType = "";
            
            			SqlConnection conn = new SqlConnection(connStr);
            			SqlCommand cmd;
            			SqlDataReader reader = null;
            			conn.Open();
                        
            			try
            			{
            				cmd = conn.CreateCommand();
            				cmd.CommandText = "SELECT ContentType FROM Repository WHERE ID = @ID";
            				cmd.Parameters.Add("@ID", SqlDbType.Int).Value = ID;
            				reader = cmd.ExecuteReader();
            				reader.Read();
            				if(!reader.IsDBNull(reader.GetOrdinal("ContentType")))
            					contentType = reader.GetString(reader.GetOrdinal("ContentType"));
            			}
            			finally
            			{
            				if(reader != null) reader.Close();
            				conn.Close();
            			}
            
            			if (string.IsNullOrEmpty(contentType))
                         contentType = 
                             MimeType.GetMimeType(System.IO.Path.GetExtension(this.fName))
                             ?? "application/octet-stream";
            			return contentType;
            		}
            	}
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.MimeType.ExtendTypesTable(System.String,System.String)">
            <summary>
            Extends the list of content types or replaces existing value with a new one.
            </summary>
            <param name="extension">File extension</param>
            <param name="mimeType">File mime type</param>
            <example>
            <code>
            MimeType.ExtendTypesTable("exten", "application/exten");
            Console.WriteLine(MimeType.GetMimeType("exten"));
            </code>
            Writes: <c>"application/exten"</c>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.MimeType.GetMimeType(System.String)">
            <summary>
            Returns the mime type corresponding to file extension.
            </summary>
            <param name="extension">File extension</param>
            <returns>String representing mime-type or null if mime-type was not found for the specified extension.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Property">
            <summary>
            Describes one property associated with hierarchy item object.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Property.Name">
            <summary>
            The name of the property.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Property.Namespace">
            <summary>
            The namespace of the property.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Property.Value">
            <summary>
            The value of the property.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Request">
            <summary>
            Represents an incoming HTTP request.
            </summary>
            <remarks>
            <para>
            <see cref="P:ITHit.WebDAV.Server.Request.ClientLockTokens"/> property provides access to the lock tokens send by WebDAV client. Before modifying locked WebDAV Class 2 server items you must check if client provided necessary lock token.
            </para>
            <para>
            Usually you do not have to implement this class if you host your server in ASP.NET/IIS or in HttpListener as Engine provides overloaded <c>Run</c> methods optimized for ASP.NET/IIS and for HttpListener. You can derive your class from this class if you host your server in any other environment and pass it to <see cref="M:ITHit.WebDAV.Server.Engine.Run(ITHit.WebDAV.Server.Request,ITHit.WebDAV.Server.IResponse)"/> method.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Request.ClientLockTokens">
             <summary>
             Gets the array of lock tokens submitted by client.
             </summary>
             <value>
             <c>StringCollection</c> object containing collection of lock tokens submitted by client.
             </value>
             <remarks>
             <c>ClientLockTokens</c> property provides access to the array of lock tokens 
             submitted by client. You must generate the lock tokens during the call to your 
             <see cref="M:ITHit.WebDAV.Server.ILock.Lock(ITHit.WebDAV.Server.LockInfo@)"/> and <see cref="M:ITHit.WebDAV.Server.IFolderLock.CreateLockNull(System.String,ITHit.WebDAV.Server.LockInfo@)"/> methods implementation. During 
             this call you associate generated token with an item in the repository and return it to the Engine. 
             Engine than sends the new token to the WebDAV client. When WebDAV client is modifying any server item it 
             sends back to server the list of lock tokens. In your WebDAV server Class 2 
             implementation before modifying any locked items you must check if WebDAV 
             client provided necessary lock token.
             </remarks>
             <example>
             <code>
             public abstract class HierarchyItem : IHierarchyItem, ILock
             {
            		...
            		internal bool ClientHasToken
            		{
            			get
            			{
            				LockInfo[] itemLocks = ActiveLocks;
            				if(itemLocks.Length == 0) 
            					return true;
            				WDRequest request = new WDRequest();
            				StringCollection clientLockTokens = request.ClientLockTokens;
            				for(int i=0; i&lt;clientLockTokens.Count; i++)
            					for(int j=0; j&lt;itemLocks.Length; j++)
            						if(clientLockTokens[i] == itemLocks[j].Token) 
            							return true;
            				return false;
            			}
            		}
            		...
            	}
            
            	public class Folder : HierarchyItem, IFolder, IFolderLock
            	{
            		...
            		public WebDAVResponse CreateFolder(string name)
            		{
            			if(!ClientHasToken)
            				return new LockedResponse();
            
            			SqlConnection conn = new SqlConnection(connStr);
            			SqlTransaction trans = null;
            			conn.Open();
            			try
            			{
            				trans = conn.BeginTransaction();
            				CreateChild(trans, name, ItemType.Folder);
            				trans.Commit();
            			}
            			catch(Exception ex)
            			{
            				if(trans != null) trans.Rollback();
            				throw;
            			}
            			finally
            			{
            				conn.Close();
            			}
            			return new CreatedResponse();
            		}
            		...
            	}
             </code>
             </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.Request.Url">
            <summary>
            Gets information about the URL of the current request.
            </summary>
            <value>
            A Uri object containing information regarding the URL of the current request.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Request.ApplicationPath">
            <summary>
            Gets virtual application root path on the server.
            </summary>
            <value>
            The virtual path of the current application.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Request.HttpMethod">
            <summary>
            Gets the HTTP method specified by the client.
            </summary>
            <value>
            A <c>String</c> that contains the method used in the request.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Request.Headers">
            <summary>
            Gets a collection of HTTP headers.
            </summary>
            <value>
            A <c>NameValueCollection</c> of headers.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Request.ContentType">
            <summary>
            Gets or sets the MIME content type of the incoming request. 
            </summary>
            <value>
            A string representing the MIME content type of the incoming request, for example, "text/html". 
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Request.ContentEncoding">
            <summary>
            Gets or sets the character set of the entity-body.
            </summary>
            <value>
            An <c>Encoding</c> object representing the client's character set.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Request.ContentLength">
            <summary>
            Specifies the length, in bytes, of content sent by the client.
            </summary>
            <value>
            The length, in bytes, of content sent by the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Request.InputStream">
            <summary>
            Gets the contents of the incoming HTTP entity body.
            </summary>
            <value>
            A <c>Stream</c> object representing the contents of the incoming HTTP content body.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Request.UserAgent">
            <summary>
            Gets the User-Agent header.
            </summary>
            <value>
            A <c>string</c> representing User-Agent header.
            </value>
        </member>
        <member name="T:ITHit.WebDAV.Logger.FileLogger">
            <summary>
            Provides static methods for writing to a log file.
            </summary>
            <remarks>
            <para>
            By default the log file is created in the folder where the calling assembly 
            resides. You can specify the folder and file name setting <see cref="P:ITHit.WebDAV.Logger.FileLogger.LogFile"/> property. 
            Amount of output and maximum file size are controlled via <see cref="P:ITHit.WebDAV.Logger.FileLogger.Level"/> and <see cref="P:ITHit.WebDAV.Logger.FileLogger.FileSize"/> properties.
            </para>
            <para>
            <b>Important!</b> If you host your server in IIS/ASP.NET make sure your log file is created outside of the \bin folder. If your logfile will be created in a \bin folder, your server will restart each time the logfile is updated, recycling application and session state.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Logger.FileLogger.LogFile">
            <summary>
            Gets and sets log file name and path.
            </summary>
            <value>
            Log file name and path.
            </value>
            <remarks>
            <para>
            By default the log file is created in the folder where the calling assembly 
            resides. The folder in which you plan store your log files must exist and 
            your web application must have enough permission for writing and creating 
            files in this folder. Note that if you are creating HttpHandler-based server usually on Windows XP your web application 
            runs under ASPNET account while on Windows 2003 it runs under Network Service account.
            </para>
            <para>
            If you are requesting your server with a WebDAV client and log file is not 
            created, most likely there is no permissions for creating file or the web 
            requests simply does not reach your application.
            </para>
            <code>
            public class WebDAVHandler : IHttpHandler
            {
            	public void ProcessRequest(HttpContext context)
            	{
            		FileLogger.LogFile = context.Request.PhysicalApplicationPath + "WebDAVlog.txt";
            		...
            	}
            	...
            }
            </code>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Logger.FileLogger.Level">
            <summary>
            Gets and sets how much information is written to log file.
            </summary>
            <value>Logging level. Default is <c>Info</c></value>
            <remarks>
            Provides the method of limiting amount of logging output. During the 
            development you will usually set <c>LogLevel</c> to <see cref="F:ITHit.WebDAV.Logger.LogLevel.All"/> or <see cref="F:ITHit.WebDAV.Logger.LogLevel.Debug"/> level, while 
            deploying you can set it to <see cref="F:ITHit.WebDAV.Logger.LogLevel.Error"/> or <see cref="F:ITHit.WebDAV.Logger.LogLevel.Fatal"/>.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Logger.FileLogger.FileSize">
            <summary>
            Gets and sets maximum log file size in bytes.
            </summary>
            <value>
            Maximum log file size in bytes. Default is 1048576 bytes.
            </value>
            <remarks>
            When the file exceeds the size specified by <c>FileSize</c> the new log file is created. The old file is renamed to &lt;filename&gt;.&lt;number&gt;.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Logger.FileLogger.MaxBackups">
            <summary>
            Gets and sets Maximum number of log file backups.
            </summary>
            <value>
            Amount of log file backups. Default is 1.
            </value>
            <remarks>
            If the amount of the backup files created is higher than <c>MaxBackups</c> the oldest file is automatically deleted.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Logger.FileLogger.WriteMessage(System.String)">
            <summary>
            Wrights a message to a log file with level <see cref="F:ITHit.WebDAV.Logger.LogLevel.Info"/>.
            </summary>
            <param name="message">Message to be logged</param>
        </member>
        <member name="M:ITHit.WebDAV.Logger.FileLogger.WriteMessage(System.String,ITHit.WebDAV.Logger.LogLevel)">
            <summary>
            Wrights a message to a log file with a specified log level.
            </summary>
            <param name="message">Message to be logged</param>
            <param name="level">Logging level</param>
            <example>
            <code>
            FileLogger.LogFile = "C:\WebDAV\WebDAVServerLog.txt"; // C:\WebDAV\ must exist and the application must have enough permission to write and create files in this folder
            FileLogger.Level = LogLevel.Warn;
            FileLogger.WriteMessage("My error message", LogLevel.Error); // this message will be written to the log file
            FileLogger.WriteMessage("My debug message", LogLevel.Debug); // this message will not be written to the log file
            FileLogger.WriteMessage("My info message"); // this message will not be written to the log file
            </code>
            </example>        
        </member>
        <member name="T:ITHit.WebDAV.Logger.LogLevel">
            <summary>
            Type of information being logged.
            </summary>
            <example>
            <code>
            FileLogger.LogFile = "C:\WebDAV\WebDAVServerLog.txt"; // C:\WebDAV\ must exist and the application must have enough permission to write and create files in this folder
            FileLogger.Level = LogLevel.Warn;
            FileLogger.WriteMessage("My error message", LogLevel.Error); // this message will be written to the log file
            FileLogger.WriteMessage("My debug message", LogLevel.Debug); // this message will not be written to the log file
            FileLogger.WriteMessage("My info message"); // this message will not be written to the log file
            </code>
            </example>
        </member>
        <member name="F:ITHit.WebDAV.Logger.LogLevel.All">
            <summary>
            All messages will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Logger.LogLevel.Debug">
            <summary>
            Messages with <c>LogLevel.Debug</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Logger.LogLevel.Info">
            <summary>
            Messages with <c>LogLevel.Info</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Logger.LogLevel.Warn">
            <summary>
            Messages with <c>LogLevel.Warn</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Logger.LogLevel.Error">
            <summary>
            Messages with <c>LogLevel.Error</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Logger.LogLevel.Fatal">
            <summary>
            Messages with <c>LogLevel.Fatal</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Logger.LogLevel.Off">
            <summary>
            No messages will be written to log.
            </summary>
        </member>
    </members>
</doc>
